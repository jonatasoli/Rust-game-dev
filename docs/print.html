<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento de Jogos online com Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-quemsou.html"><strong aria-hidden="true">1.1.</strong> Quem sou eu? (Sobre a autora)</a></li></ol></li><li class="chapter-item expanded "><a href="part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Conceitos Básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predição e Reconciliação</a></li><li class="chapter-item expanded "><a href="part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpolação de Entidades</a></li><li class="chapter-item expanded "><a href="part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensacão de Lag</a></li></ol></li><li class="chapter-item expanded "><a href="part-2/00-intro.html"><strong aria-hidden="true">3.</strong> Multiplayer Snake Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-2/01-bevy.html"><strong aria-hidden="true">3.1.</strong> Sobre a Bevy</a></li><li class="chapter-item expanded "><a href="part-2/02-ecs.html"><strong aria-hidden="true">3.2.</strong> Entity Compoent System</a></li><li class="chapter-item expanded "><a href="part-2/03-cabeca.html"><strong aria-hidden="true">3.3.</strong> A Cabaça da Cobra</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="desenvolvimento-de-jogos-online-com-rust"><a class="header" href="#desenvolvimento-de-jogos-online-com-rust">Desenvolvimento de Jogos Online com Rust</a></h1>
<p>Por Julia Naomi Boeira.</p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<p>Escrever um livro open source é um trablho que precisa de incentivo e por isso Github Sponsor e Patreon são coisas importantes, pois além de atuarem como incetivo, são um bomr econhecimento do nosso trabalho. Escrevi bastantes livros pela casa do código, mas em especial no assunto Rust e Games eu sinto que falta alcance, e por isso gostaria de continuar produzindo esse tipo de material.</p>
<h2 id="sobre-o-livro"><a class="header" href="#sobre-o-livro">Sobre o livro</a></h2>
<p>Até o momento planejei 3 partes para este livro:</p>
<ol>
<li><a href="part-1/00-capa.html">Conceitos Básicos</a>, onde vamos falar sobre como funciona um jogo online e quais são suas limitações.</li>
<li>Jogo da cobrinha com a engine Bevy, essa é a parte menos criativa do processo e é uma cópia traduzida deste tutorial <a href="https://mbuffett.com/posts/bevy-snake-tutorial/">Bevy Snake Tutorial</a>. A diferença é que vou adicionar elementos de um jogo multiplayer local.</li>
<li>Servidor autoritário com a Bevy.</li>
</ol>
<p>ESPERO QUE APROVEITEM A LEITURA e feedbacks são bem vindos. </p>
<h1 id="quem-sou-eu"><a class="header" href="#quem-sou-eu">Quem sou eu</a></h1>
<p>Eu sou uma desenolvedora de jogos na Ubisoft Winnipeg atuando no desenvolvimento de sistemas online, middlewares e ferramentas para jogos. Trabalho principalmente com C++, mas um pouco de C# e Rust. Sou autora dos livros:</p>
<ul>
<li>📖 <a href="https://www.apress.com/gp/book/9781484232156">Lean Game Development - Inglês - Apress</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-lean-game-development">Lean Game Development - Português - Casa do Código</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-rust-funcional-concorrente">Programação Funcional e Concorrente em Rust - Casa do Código</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-tdd-games">TDD para Games - Casa do Código</a></li>
<li>📖 <a href="https://github.com/naomijub/web-dev-rust-book">[OPEN SOURCE] Desenvolvimento Web com Rust</a></li>
</ul>
<p>E atualmente estou desenvolvendo em paralelo a este livro o livro <a href="https://github.com/naomijub/Unity-FPS-game-with-TDD-Book">Unity FPS game with TDD - Inglês</a>.</p>
<p>Tenho atuado como evangelista voluntaria de Rust desde 2017 quando me deparei com Rust pela primeira vez e percebi que esta maravilhosa linguagem era um raio de esperança nos problemas que eu tinha no desenvolvimento de jogos com C++.</p>
<p>Hobbies como engenheira são aprender novas linguagens, em especial de paradigmas diferentes ou que pelo menos possuem uma forma bem diferente de resolver problemas, tornando Clojure e Elixir minhas duas outras linguagens favoritas. E no meu tempo livre escrever e fazer prototipos bobos de jogos como esses (quando eu estava aprendendo Java) https://github.com/naomijub/DiammondSeek e https://github.com/naomijub/PacmanLabyrinth.</p>
<p>Curiosidade sobre aprender linguagens de programação, tentei aprender Java na faculdade, mas simplesmente não entrava na minha cabeça, foi graças a XNA e aos C# que consegui aprender Java e arrumar trabalho com software corporativo. Tentei aprender Go 3 vezes e NUNCA entra na minha cabeça. Trabalhei muito com Python a ponto de dizer que era uma das minhas linguagens favoritas, mas hoje em dia eu fujo de qualquer projeto Python.</p>
<p>Passei pelas faculdades de Matematica Aplicada, Engenharia de Materiais e Ciências da Computação. Larguei a CC porque já estava cursando mestrado em inteligência artificial aplicada a engenharia de materiais e depois aiinda fiz especialização em desenvolvimento de jogos para suprir as áreas que faltavam do meu conhecimento em jogos. A empresa que mais gostei de trabalhar é a Ubiisoft DE WINNIPEG, mas outras empresas que gostei muito foram a Thoughtworks até 2018, onde conheci pessoas incríveis que são minhas amigas até hoje, e Nubank que foi um lugar de muito aprendizado.</p>
<p>Para dúvidas sobre o livro, discussões sobre o tema e correções sugiro abrir <a href="https://github.com/naomijub/Rust-game-dev/issues">issues</a> ou criar <a href="https://github.com/naomijub/Rust-game-dev">Pull Requests</a>.</p>
<h1 id="conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais"><a class="header" href="#conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais">Conceitos importantes para o desenvolvimento de serviços de jogos digitais</a></h1>
<ol>
<li>O problema e sua arquitetura básica.</li>
<li>Predição e reconciliação.</li>
<li>Interpolação de entidades.</li>
<li>Compensação de lag.</li>
</ol>
<h1 id="o-problema-e-sua-arquitetura-básica"><a class="header" href="#o-problema-e-sua-arquitetura-básica">O problema e sua arquitetura básica.</a></h1>
<p>Neste capítulo vamos entender quais os problemas que serviços para games enfrentam e quais são algumas das formas de resolvê-los para obtermos um conjunto de serviços que tornam o desenvolvimento de jogos multiplayer uma realidade. </p>
<blockquote>
<p><em>Multiplayer</em></p>
<p>Jogos multiplayer são jogos com mais de uma pessoa jogando simultaneamente se conectando através de um servidor.</p>
</blockquote>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Desenvolver um jogo é bastante complicado, agora desenvolver um jogo para mais de uma pessoa jogando é ainda mais complicado. Felizmente, podemos resumir os problemas que servidores de jogos possuem em duas categorias:</p>
<ol>
<li>Humanos maliciosos.</li>
<li>Física realística.</li>
</ol>
<h3 id="humanos-maliciosos"><a class="header" href="#humanos-maliciosos">Humanos Maliciosos</a></h3>
<p>Tudo começa com o desejo das pessoas de trapacear em um jogo.</p>
<p>Podemos dizer que para jogos single-player, ou de somente uma pessoa jogando, trapacear afeta a experiência, mas é uma escolha da pessoa burlar a experiência do jogo, a final a trapaça não afeta ninguém além da pessoa, porém para jogos multiplayer o cenário é diferente. Em um jogo multiplayer, uma pessoa burlando as regras do jogo pode conseguir algumas vantagens que além de afetar sua experiência, tornam a experiência das outras pessoas muito pior. Alguns exemplos que já vi na minha vida:</p>
<ul>
<li>Vida muito maior que 100%, ou seja, a pessoa possuia 1000% de vida em uma partida, tornando ela quase imortal, já que colecionava muito mais recursos.</li>
<li>Tiros duplos ou triplos, ou seja, para cada vez que a pessoa realizava um tiro, duas ou três balas eram enviadas ao mesmo tempo, reduzindo muito as chances do alvo de sobreviver.</li>
<li>Atravessar paredes, não sei bem como este mod funcionava, mas acredito que projetava a pessoa para além do objeto de colisão.</li>
<li>Paredes invisíveis, ou seja, a pessoa havia removido a renderização de objetos inanimados, o que a permitia visualizar todos os alvos antes de ser percebida.</li>
<li>Velocidade 2, ou seja, para cada passo da pessoa, o jogo a movia 2 vezes mais rápido.</li>
</ul>
<p>Tendo estes eventos em mente, podemos concluir que existe uma única solução realmente confiável para um servidor NÃO CONFIAR NO USUÁRIO.</p>
<h2 id="como-não-confiar-no-usuário"><a class="header" href="#como-não-confiar-no-usuário">Como não confiar no usuário?</a></h2>
<p>A resposta para está pergunta é na verdade bastante simples, o cliente, ou seja a pessoa jogando, deve fornecer o mínimo de informações em relação ao seu posicionamento, balas disparadas, direção, etc. Enquanto isso, o servidor deve ser autoritário, recendendo estes comandos básicos e informado para o cliente o que está acontecendo. Em outras palavras, o cliente envia comandos e botões pressionados para o servidor, o servidor executa o próximo passo do jogo e devolve ao cliente as novas informações. Isso não vai impedir que o servidor seja explorado de vulnerabilidades, mas reduzirá drasticamente a capacidade de uma pessoa jogando de trapacear. Assim, para o caso da pessoa que está dando tiros múltiplos, ela pode até ver 3 tiros saindo de sua arma, mas o servidor reconhecerá somente 1 e propagará ao resto do jogo somente 1. </p>
<p>Resumindo, o gerenciamento do estado do jogo é realizado apenas pelo servidor. Clientes enviam apenas suas interações com o controle, teclado e mouse para o servidor. O servidor atualiza o estado do jogo e envia esta informação de volta aos clientes que apenas renderizam ela em sua tela.</p>
<h2 id="o-problema-com-a-física"><a class="header" href="#o-problema-com-a-física">O problema com a física</a></h2>
<p>Parece uma solução perfeita né? Infelizmente ela funciona bem somente quando o jogo é baseado em turnos, como jogos de carta e alguns RPGs, ou a rede é em LAN, já que neste cenário a comunicação com o servidor é considerada instantânea. Para jogos como Call of Duty e Rainbow Six está estratégia vai contar com um enorme delay já que precisam se conectar com servidores distantes.</p>
<p>Assim, vamos supor o meu cenário. Mesmo que minha conexão à internet seja sensacional (mentira, isso não existe), estou em Porto Alegre e o servidor mais próximo está em São Paulo para o jogo X. Porto Alegre e São Paulo estão distantes entre si mais de 1100 km. Na física a velocidade da luz é a maior velocidade atingível por um corpo (photons no caso), ou seja 300.000 km/s no vácuo, assim a luz levaria 3,7 milisegundos para percorrer os 1100 km (1100/300000 = 0,0036667 segundos). Essa é a velocidade da luz no vácuo, parece bem otimista né? Mas neste caso estamos falando de bytes trafegando pela internet, que na prática são elétrons e pulsos de luz trafegando por um cabo, e provavelmente não em linha reta, o que deve aumentar esse valor de 3,7 por alguns microsegundos. Existe mais um fator importante em como a internet funciona, os dados trafegados pela internet são na verdade uma séries de pacotes, ou <em>hops</em>, que trafegam de um roteador ao outro, certamente abaixo da velocidade da luz. Além disso, roteadores possuem um atraso extra, já que todos os pacotes devem ser abertos, copiados e inspecionados para então serem reroteados a seus destinos finais.</p>
<p>Vamos então dizer que o atraso dos meus pacotes até São Paulo leva 25 ms, o que seria um tempo excepcional (neste momento um ping da minha máquina ao google.com está levando entre 25 e 30 ms), mas tempos de 50 ms e até 200 ms não seria impressionantes para certas situações. Agora vamos dizer que nossa jogadora apertou para atirar no momento x, isso quer dizer que nosso servidor receberá a ação de atirar 25 ms depois. Digamos que nosso servidor processe o evento em um tempo substancialmente menor que 1 milisegundo, algo como 500 us, isso quer dizer que quando o servidor responder, a jogadora receberá essa atualização 50 ms depois de ter clicado para atirar. Humanos em média enxergam 25 frames por segundo, o que indica que o delay já é maior que nossa capacidade de observação por 10 ms. Esses 10 ms de delay na nossa percepção já são suficiente para termos uma experiência ruim de jogabilidade, ou seja, o famoso <em>lag</em>, ou atraso. A imagem a seguir demonstra este efeito:</p>
<p><img src="part-1/../imagens/ping_time.jpg" alt="Diagrama de atraso na conexão cliente servidor" /></p>
<h1 id="predição-e-reconciliação"><a class="header" href="#predição-e-reconciliação">Predição e Reconciliação</a></h1>
<p>No capítulo anterior falamos sobre o lag, ou atraso entre ação no cliente e a atualização enviada pelo servidor nos baseando no modelo de cliente servidor na qual o cliente não responde seu estado, mas sim a ação desejada, para que o servidor atualize seu estado. Um jogo que pode levar algumas frações de segundo para atualizar o estado pode ser considerado de jogabilidade ruim ou injogável devido ao lag de renderização. Assim, neste capítulo vamos explorar uma solução para minimizar este problema.</p>
<h2 id="predição-pelo-lado-do-cliente"><a class="header" href="#predição-pelo-lado-do-cliente">Predição pelo lado do cliente</a></h2>
<p>Como a maior parte dos jogos é deterministico, ou seja, não há aleatoriedade no resultado, podemos prever qual vai ser o próximo passo do jogo antes do servidor responder. Para maior parte das pessoas jogando esta experiência será &quot;idêntica&quot; ao jogo sem servidor, mas para as pessoas trapaceando a experiência não será realistica, desfavorecendo o jogo com trapaças. Assim, podemos assumir que nosso servidor receberá ações válidas para 99% dos casos, nos permitindo prever o próximo instante.</p>
<p>No cenário que descrevemos anteriormente nossa ação com o servidor levava 50 ms para atualizar o estado do jogo, para só então uma animação ser ativada (digamos que ela leve mais 50 ms) como a imagem a seguir nos mostra:</p>
<p><img src="part-1/../imagens/animation_time.jpg" alt="Diagrama de atraso na conexão cliente servidor com tempo de animação" /></p>
<p>Nessa imagem podemos ver que o atraso do servidor (50 ms) mais o tempo de animação (50 ms) fará com que percebemos o tiro apenas 100 ms depois dele ter sido realizado, ou seja, no terceiro frame que nosso olho detecta, certamente uma experiência desagradável. </p>
<p>Como o jogo nosso jogo é deterministico, podemos presumir que a ação será executada com sucesso no servidor, aplicar nossas regras locais de validação e iniciar a animação do tiro no momento em que pressionamos o botão para realizar a ação. Para a grande maioria dos casos a atualização do servidor e o final da animação vão coincidir em estado e fizemos um predição bem sucedida, fazendo com que não exista atrasos entre a ação e a renderização. Para os casos de trapaça a animação ocorrerá, mas em nada afetará o estado geral do jogo, somente afetará negativamente a experiência do usuário trapacendo.</p>
<h3 id="problemas-de-sincronização"><a class="header" href="#problemas-de-sincronização">Problemas de sincronização</a></h3>
<p>Infelizmente essa estratégia não é perfeita e problemas de sincronização ou eventos conflitantes podem acontecer. Imagine agora o cenário na qual o personagem está se movimentando e o tempo de atraso é 75 ms em vez dos 50 ms anteriores, o tempo da animação é de 30 ms e a pessoa pressiona para se movimentar para frente 2 vezes seguidas. A imagem a seguir e os passos marcados na imagem exemplificam:</p>
<p><img src="part-1/../imagens/sync_problem.jpg" alt="Diagrama com problemas de sincronização de ações" /></p>
<ol start="0">
<li>Personagem está o ponto <code>(0,0)</code> no instante 0 ms.</li>
<li>Neste mesmo instante a pessoa pressiona para se movimentar enviando uma ação para o servidor que durará 75 ms.</li>
<li>A ação do passo 1 ativou uma animação que moveu o personagem para a posição <code>(0,1)</code> 30 ms depois.</li>
<li>Na posição <code>(0,1)</code> uma nova ação de movimentação acontece, enviando esta nova ação para o servidor que durará mais 75 ms.</li>
<li>A ação do passo 3 ativou uma nova animação que moveu o personagem para a posição <code>(0,2)</code> 30 ms depois. Já se passaram 60 ms.</li>
<li>15 ms depois de terminar a ação 4, o servidor respondeu a ação 1 fazendo o personagem voltar para posição <code>(0,1)</code>. Já se passaram 75 ms.</li>
<li>30 ms depois de terminar a ação 5, o servidor respondeu a æção 3 fazendo o personagem voltar para posição <code>(0,2)</code>. Ja se passaram 105 ms.</li>
</ol>
<p>Com este detalhamento podemos ver que pelo ponto de vista da pessoa jogando, o personagem vai responder as duas primeiras ações se movimentando até a posição <code>(0,2)</code> para então voltar para posição <code>(0,1)</code> e depois ainda voltar para posição <code>(0,2)</code> gerando uma péssima experiência de jogo, forçando assim a adotarmos uma estratégia de reconciliação.</p>
<h2 id="reconciliacão-pelo-servidor"><a class="header" href="#reconciliacão-pelo-servidor">Reconciliacão pelo servidor</a></h2>
<p>A chave deste problema é entender a diferença temporal dos cliente e do servidor, já que o cliente vê o jogo em tempo real (presente) e o servidor autoritário está no passado. Assim, sempre haverá uma diferença de sequência de comandos a serem processados entre o cliente e o servidor. Felizmente isso não é muito difícil de resolver.</p>
<p>Primeiro passo é fazer com que o cliente salve suas ações em uma sequência de comandos, assim a primeira movimentação seria a ação <code>#1</code> e a segunda movimentação seria a ação <code>#2</code>. Logo, o servidor poderá respoderá responder uma ação identificando a qual comando ela pertence. A figura a seguir exemplifica o que acontece:</p>
<p><img src="part-1/../imagens/reconciliacao.jpg" alt="Diagrama de reconciliação de ações" /></p>
<ol>
<li>O evento <code>#1</code> é lancado, 30 ms depois da animação a posição <code>#1 =&gt; (0,1)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#1</code>. A sequência de comandos é <code>[#1 =&gt; (0,1)]</code>.</li>
<li>O evento <code>#2</code> é lancado, 30 ms depois da animação a posição <code>#2 =&gt; (0,2)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#2</code>.  A sequência de comandos é <code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>.</li>
<li>O evento <code>#1</code> é retornado pelo servidor com o valor <code>#1 =&gt; (0,1)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>) e o evento <code>#1 =&gt; (0,1)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#1 =&gt; (0,1)</code> da sequência de comandos.</li>
<li>O evento <code>#2</code> é retornado pelo servidor com o valor <code>#2 =&gt; (0,2)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#2 =&gt; (0,2)]</code>) e o evento <code>#2 =&gt; (0,2)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#2 =&gt; (0,2)</code> da sequência de comandos.</li>
<li>Sequência de comandos é <code>[]</code>.</li>
</ol>
<blockquote>
<p><strong>Descrição da função <code>check</code></strong></p>
<ol>
<li>Argumentos são <strong>sequência de comandos executados</strong> e <strong>evento #</strong>.</li>
<li>Verifica se o valor de <code>#n</code> na sequência de comando é igual ao que o servidor retornou. Caso não for igual retorna erro.</li>
<li>Aplica o próximo evento, <code>#n+1</code>, ao resultado do evento <code>#n</code>. Caso o resultado de <code>#n</code> mais o evento <code>#n+1</code> não corresponder ao evento salvo na sequência de comandos para <code>#n+1</code> retornar erro.
<strong>Observação</strong>: Se o evento que o servidor responder não for <code>#n</code> esperado, podemos concluir que o pacote se perdeu ou o servidor retornou um erro, assim existem duas alternativas <strong>1.</strong> descartar todos os pacotes até o evento recebido e fazer o check, ou <strong>2.</strong> aplciar todos os eventos anteriores até o evento recebido. Particularmente vejo a soluação <strong>1</strong> sendo a mais comum, pois sabemos que o estado anterior está certo.</li>
</ol>
</blockquote>
<p>Este é um exemplo bem simples de movimentação e bastante intuitivo de visualizar, mas as aplicações de predição e reconciliação podem ser feitas em praticamente qualquer área do jogo e qualquer tipo de jogo. Imagine um jogo de corrida multiplayer e você está na linha de chegada em velocidade máxima, com um carro logo atrás de você. No próximo segundo considerando as atuais circunstâncias, é óbvio que você vai ganhar, pois você está na frente do outro carro e com uma velocidade maior, mas agora imagine que alguns milésimos antes do final da corrida a outra pessoa apertou o botão de nitro e te ultrapassou. A predição diria que seu carro ganharia a corrida, mas o servidor disse que não e você ficou em segundo lugar. Isso nos leva a um ponto interessante, mesmo em ambientes determinísticos, existe a chance da predição e da reconciliação não serem iguais, Para um cenário de fim de jogo como descrito aqui é bastante trivial a resposta, ignore a predição e responda com o resultado do servidor, porém se isso acontecer frequentemente no meio do jogo a experiência de jogabilidade vai ser ruim.</p>
<p>No próximo capítulo vamos explorar como resolver este problema de predição e reconciliação através de interpolação de entidades.</p>
<h1 id="interpolação-de-entidades"><a class="header" href="#interpolação-de-entidades">Interpolação de Entidades</a></h1>
<p>Nos capítulos anteriores lidamos com o problema de uma pessoa poder trapacear e como fazer com que o jogo se mantenha conciliado com um servidor autoritário dando a sensação de que o servidor não existe, porém não expandimos este problema para quando estamos lidando com mais de uma pessoa jogando online. Neste capítulo vamos explorar técnicas que nos permitem manter a jogabilidade quando várias pessoas estão interagindo umas com as outras em um ambiente online.</p>
<h2 id="lidando-com-centenas-de-ações-simultâneas"><a class="header" href="#lidando-com-centenas-de-ações-simultâneas">Lidando com centenas de ações simultâneas</a></h2>
<p>No capítulo anterior falamos sobre o servidor processar uma sequência de comandos e retornar como eventos autoritários para o cliente. Imagine agora que este cliente está alucinadamente mandando eventos para o servidor e que ele não está sozinho, pois existem mais uma dezena de clientes mandando eventos simultaneamente para o servidor. Sendo assim, atualizar o estado do jogo para cada comando recebido de cada cliente e depois transmitir o estado do jogo de volta para cada cliente consumiria muita CPU e muita banda.</p>
<p>Tendo em vista evitar o consumo desnecessário de CPU e banda outra abordagem parece fundamental. Esta nova abordagem consiste em enfileirar os comandos que os clientes enviam, sem processar eles, e em vez de atualizar o estado do jogo imediatamente para cada comando, fazemos atualizações periódicas e de baixa frequência, por exemplo 10 vezes por segundo. Este atraso entre cada update, no caso do nosso exemplo de 100 ms, é chamado de <em>time step</em>, ou passo temporal. O <em>time step</em> é definido como uma iteração de loop de update na qual todas as informações não processdas de todos clientes são aplicadas e o novo estado é transmitido para todos os clientes. Ou seja, o estado do jogo é atualizado com uma periodicidade específica de forma independente e não é afetado pela quantidade de clientes e seus comandos.</p>
<p><strong>Obs</strong>: Muitas vezes a física do jogo é atualizada em passos de tempo menor para aumentar a previsibilidade.</p>
<h2 id="updates-de-baixa-frequência"><a class="header" href="#updates-de-baixa-frequência">Updates de baixa frequência</a></h2>
<p>Seguindo com o conceito de um update de estado a cada 100 ms um novo problema aparece, os outros clientes não tem ideia de como seus oponentes estão se atualizando, gerando eventos que parecem bastante bruscos a cada atualização. Ou seja, predição e reconciliação funcionam muito bem para o lado do cliente, mas não para o resto das pessoas jogando. A imagem a seguir detalha melhor essa situação:</p>
<p><img src="part-1/../imagens/step_time.jpg" alt="Diagrama de efeitos do step time para dois clientes" /></p>
<p>Na imagem anterior podemos ver o mesmo cenário de predição e reconciliação funcionando muito bem para o <code>Cliente 1</code>, permitindo que sua jogabilidade seja coerente com a jogabilidade de um jogo single-player, porém para o <code>Cliente 2</code> podemos ver que as transições <code>(0,0) -&gt; (0, 1)</code> e <code>(0, 1) -&gt; (0, 2)</code> do <code>Cliente 1</code> são bruscas para o <code>Cliente 2</code>, já que estas atualizações dependem exclusivamente das atualizações do servidor.</p>
<p>Agora voltando ao exemplo dos carros que mencionamos no final do capítulo anterior. Estamos em uma situação na qual temos controle do nosso carro, mas o carro da outra pessoa é determinado pelo servidor. Se este carro recebe atualizações apenas a cada 100 ms, teremos uma animação péssima de seu deslocamento, nos obrigando a encontrar outra solução para melhorar a experienência. Esta outra soluação envolve fazer a predição da posição do outro carro do lado do nosso cliente, pois sabemos sua direção, sua velocidade e temos certeza que o carro não fará um movimento radical, como girar 180 graus. Sendo assim, se o outro carro está indo reto com uma velocidade de 100 km/h, podemos prever que nos próximos 100 ms o carro estará 0,2 metros a frente de onde ele está neste exato segundo. Essa predição pode parecer maravilhosa, já que ele só se deslocou 0,2 metros em linha reta, mas infelizmente 100 ms é tempo suficiente para muitas outras coisas acontecerem como uma curva aparecer, bater em um poste, desacelerar ou até mesmo frear bruscamente. Chamamos está técnica de <strong>dead reckoning</strong>. Portanto, o <strong>dead reckoning</strong> é uma técnica de predição dos movimentos de outras pessoas em jogos na qual sua posição, velocidade e direção não são afetadas de forma instantânea, permitindo uma pequena margem para prever movimentos sem grandes danos à experiência. Caso alguma ação inesperada aconteça aceitamos que vamos conviver com uma cena estranha.</p>
<blockquote>
<p><strong>Dead reckoning</strong> é originalmente uma estratégia militar para prever a próxima localização de um navio, que se move lentamente e sem grandes oscilações de direção, para que se possa prever onde um torpedo precisa ser lançado para acertar o navio.</p>
</blockquote>
<h2 id="e-para-cenários-muito-dinâmicos"><a class="header" href="#e-para-cenários-muito-dinâmicos">E para cenários muito dinâmicos?</a></h2>
<p>Como falamos anteriormente, <em>dead reckoning</em> é bom para jogos que não são tão dinâmicos, como jogos de corrida, porém para jogos na qual as pessoas jogando se movimentam constantemente, atiram, se abaixam, pulam, giram 180 graus é impossível prever o próximo passo da pessoa apenas com dados anteriores. Se aplicássemos dead reckoning em um jogo de tiro veríamos personagens se teletransportando pequenas distâncias, múltiplas balas saindo de diferentes lugares e personagens fazendo movimentos impossíveis. Sendo assim, outra estratégia é necessária para jogos de tiro, sendo essa a <strong>interpolação de entidades</strong>.</p>
<p>No cenário descrito do parágrafo anterior, temos certeza apenas de 1 coisa, que a cada 100 ms temos uma atualização das informações do estado do jogo e dos personagens. Tendo em vista que sabemos o passado todo, o truque é mostrar para pessoa jogando o que acontece entre esses dados que já sabemos. Ou seja, a solução é mostrar para a pessoa que está jogando o passado relativo dos outros personagens. Isso que chamamos de <strong>interpolação de entidades</strong>.</p>
<p>Explicando melhor, podemos dizer que no momento <code>t = n + 1</code>, que você acabou de receber, a posição do momento <code>t = n</code> é conhecida. Sendo assim, neste momento <code>t = n + 1</code> conhecemos as posições referentes a <code>t = n</code> e <code>t = n + 1</code>. Portanto, para o momento <code>t = n + 2</code> mostramos o passado, ou seja, o que ocorreu no momento <code>t = n = 1</code> e para o momento <code>t = n + 1</code> mostramos o que ocorreu no momento <code>t = n</code> do outro personagem. Deste modo o servidor está sempre mostrando as informações reais de movimentação dos outros personagens, porém com um &quot;pequeno atraso&quot; de 100 ms. A imagem a seguir exemplifica:</p>
<p><img src="part-1/../imagens/interpolation.jpg" alt="Diagrama de interpolação" /></p>
<p>O diagrama de interpolação nos mostra bem como estamos prevendo os passos intermediários. Para um momento inicial estamos com a posição <code>P(0,1)</code>, depois o servidor nos atualiza com a posição <code>P(0,1)</code> novamente, neste momento exibimos a posição que conheciamos antes do <em>step time</em>, a <code>V(0,1)</code>. Quando recebemos a posição <code>P(0,2)</code>, mantemos a posição <code>V(0,1)</code>, que havia sido entregue anteriormente pelo servidor. Agora sabemos o vetor de posições <code>[P(0, 1), #1 P(0, 1), #2 P(0, 2)]</code>, e podemos interpolar que no próximo <em>step time</em> nosso personagem inimigo vai para a posição <code>V(0,2)</code> passando pela posição <code>V(0,1.75)</code>, melhorando a experiência da pessoa jogadora.</p>
<p>Na maior parte dos casos interpolação funciona muito bem, porém existem alguns casos que pode ser importante enviar mais informações de posições intermediárias entre <code>#1</code> e <code>#2</code>. Ou seja, se atualizações de estado a cada 100 ms não são suficientes, podemos enviar as últimas 10 atualizações que ocorreram com intervalos de 10 ms, que certamente vai fazer com que seu jogo pareça mais realista. Note que está técnica faz com que cada jogadora perceba pequenas variações do ambiente do jogo em relação às outras pessoas, que geralmente não é algo perceptível. Infelizmente, nada é perfeito e existem exceções como no caso de quando damos um tiro, pois estamos atirando na personagem da outra pessoa de 100 ms atrás. É nesse caso que precisamos explorar o último tópico desta parte, compensação de lag.</p>
<h1 id="compensacão-de-lag"><a class="header" href="#compensacão-de-lag">Compensacão de Lag</a></h1>
<p>O cenário que temos até agora parece funcionar muito bem para percebermos movimentações, pois temos:</p>
<ul>
<li>Dado um tempo n, nosso servidor recebe informações de todos os clientes.</li>
<li>Servidor processa todas as informações e transmite as atualizações.</li>
<li>Estas atualizações são periódicas e de baixa frequência.</li>
<li>Clientes enviam informações e verificam seus efeitos localmente.</li>
<li>Clientes recebem as atualizações de estado do jogo:
<ol>
<li>Reconciliam com os efeitos que previram.</li>
<li>Interpolam os efeitos dos outros personagens.</li>
</ol>
</li>
<li>Cliente se vê no presente, mas vê os outros cliente no passado.</li>
</ul>
<p>Esta situação é geralmente ótima, a menos quando precisamos garantir situações como um tiro na cabeça, que qualquer pequena variação pode causar um erro, pois as informações de tempo e espaço são muito sensíveis. É ai que entra a compensação de lag.</p>
<p>Imagine o cenário na qual você é uma sniper mirando perfeitamente na cabeça de um personagem &quot;imóvel&quot;, um tiro dificil de errar. Você atira e, magicamente, nada acontece. Você se irrita, sai da partida e desliga o jogo pensando como pode ter errado aquele tiro perfeito e, pior, a pessoa que você devia ter matado te matou. Este é o efeito de lag temporal, pois seu tiro ocorreu em um personagem que estava 100 ms no passado, para quem gosta de física, é como se a velocidade da luz fosse muito muito muito inferior a que realmente é. Felizmente, existem algumas estratégias para resolver este efeito. Vamos detalhar como isso pode ser reolvido:</p>
<ol>
<li>Você deu um tiro, seu cliente enviou as informações para o servidor, mas desta vez enviou mais informações além do botão que você clicou, pois enviou o botão que você apertou, o exato momento temporal que você apertou o botão (e se o botão de mira estava sendo apertado) e o que estava exatamente em sua mira neste instante.</li>
<li>Como o servidor está recebendo todos momentos temporais, ele pode reconstruir os eventos temporalmente ordenados, ou seja, o servidor pode reconstruir o mundo no exato momento de seu tiro, assim como para todos outros clientes.</li>
<li>Sabendo o que sua arma estava mirando no momento de seu tiro, a cabeça de seu inimigo, seu presente passa a ser considerado como válido no servidor, já que ele compensa esta diferenca.</li>
<li>O servidor processa o tiro e transmite para todos os clientes, deixando seu oponente furioso por ter levado um headshot.</li>
</ol>
<p>E é no passo dois que a compensacão de lag ocorre.</p>
<h2 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h2>
<p>Primeira coisa que fizemos foi entender qual o grande problema do desenvolvimento de servidores para jogos, pessoas querendo trapacear, e a partir disso entendemos qual a solução básica, um cliente que só envia comandos pro servidor e um servidor autoritário. Vimos que com um servidor autoritário alguns problemas de defasamento temporal pode ocorrer entre a informação que temos e a informação que o servidor nos obriga a ter. Para reduzir estes problemas aprendemos as técncias de predição e de reconciliação, mas descobrimos problemas de sincronização com outros clientes. Para resolver os problemas de sincronização aprendemos as técncias de dead reckoning e interpolação de entidades, que são ótimas técnicas, mas ainda podem falhar na hora que ações muito sensíveis espacialmente são executadas. Para resolver este problema de ações sensíveis, aprendemos compensação de lag, mas ainda nos falta por a mão na massa. Nos próximos capítulos vamos explorar um jogo simples de tiro e um exemplo de servidor para ele.</p>
<h1 id="multiplayer-snake-game"><a class="header" href="#multiplayer-snake-game">Multiplayer Snake Game</a></h1>
<h1 id="sobre-a-bevy"><a class="header" href="#sobre-a-bevy">Sobre a Bevy</a></h1>
<p>Bevy engine é uma das game engines mais promissoras do mercado e um grande esforço coletivo para a comunidade rust_gamedev. Se trata de uma engine orientada a dados, gratuíta e open source, sob as licenças Apache e MIT, ou seja, perfeita para qualquer projeto. Ela possui como objetivos de design:</p>
<ul>
<li>Um conjunto completo de features para jogos 2D e 3D, podendo inclusive ser aplicada para outros objetivos.</li>
<li>Simples e poderosa, mas mantendo o fácil aprendizado.</li>
<li>Orientada a dados utilizando o paradigma ECS (Entity component system, no próximo capítulo).</li>
<li>Modular, use o que quiser, adicione o que quiser, e substitua o que quiser.</li>
<li>Rápida, paralela e em Rust &lt;3.</li>
<li>Compilação rápida</li>
</ul>
<p>A atual versão da Bevy é <a href="https://crates.io/crates/bevy"><img src="https://img.shields.io/crates/v/bevy.svg" alt="Crates.io" /></a> e este livro foi desenvolvido com a versão <code>0.7</code>.</p>
<h2 id="iniciando-o-projeto"><a class="header" href="#iniciando-o-projeto">Iniciando o projeto</a></h2>
<blockquote>
<p>Para iniciar um projeto com a Bevy é necessário possuir Rust e Cargo, caso você não possua basta fazer download em https://rustup.rs/.</p>
</blockquote>
<p>Vamos iniciar nosso projeto com um simples <code>cargo new bevy-snake --bin</code>, que gera um projeto executável em Rust chamado <code>bevy-snake</code>. Este projeto vai possuir um <code>Cargo.toml</code> (onde os metadados do projeto estão localizados), um <code>src/main.rs</code> e um <code>.gitignore</code>:</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<pre><code class="language-sh"># .gitignore 
/target
</code></pre>
<p>Agora adicionamos versão atual da bevy (<code>bevy = &quot;0.7&quot;</code>) a seção <code>[dependencies]</code> do Cargo.toml. Adicionamos também a crate de aleatoriedade <code>rand</code>:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.7&quot;
rand = &quot;0.7&quot;
</code></pre>
<p>Com essas mudanças no <code>Cargo.toml</code> podemos começar a usar o <code>prelude</code> da bevy e criar nosso primeiro app com:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new().run();
}
</code></pre></pre>
<h3 id="instanciando-uma-janela"><a class="header" href="#instanciando-uma-janela">Instanciando uma Janela</a></h3>
<p>Instanciar uma janela com a Bevy é bastante trivial e pode ser feito através do uso de plugins, neste caso o <code>DefaultPlugins</code> contém um conjunto básico de plugins que tornam a bevy operacional:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new().add_plugins(DefaultPlugins).run();
}
</code></pre></pre>
<p>Agora se executarmos <code>cargo run</code> veremos uma janela com fundo cinza. Por padrão, os plugins da Bevy não incluem camera, pois o uso de camera é muito variado em jogos, assim, precisamos criar nosso próprio sistema de cameras. Usaremos uma camera ortográfica 2D com o commando <code>OrthographicCameraBundle::new_2d()</code> em uma função que fará a configuração do sistema de cameras inicial alterando a variável do tipo <code>mut Commands</code>. <code>Commands</code> é um tipo muito comum ao escrever sistemas com a Bevy e é usado para enfileirar comandos com o objetivo de modificar o mundo (que chamaremos de <code>world</code>) e os recursos (que chamaremos de <code>resources</code>). Assim, na função a seguir, <code>setup_camera</code>, receberemos como argumento <code>mut commands: Commands</code> e utilizaremos ele para instanciar (chamado de <code>spawn</code>) uma nova entidade bundle com os componentes de uma câmera 2D ortográfica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
<span class="boring">}
</span></code></pre></pre>
<p>E agora basta adicionar esse função ao nosso <code>App</code> através de um <code>add_startup_system</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugins(DefaultPlugins)
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>A Bevy é pensada de forma que todas suas partes sejam modularizáveis, assim, todas as core features da engine são implementadas como plugins que podem ser substituídos, evoluídos e customizados, além disso, os próprios jogos são encarados como plugins. Assim, se você não precisar de uma UI, basta não registrar o sistema de UI, quer um sistema de UI diferente, registre o seu próprio. Para o caso de servidores, basta não registrar o plugin <code>RenderPlugin</code>.</p>
<p>Caso você não precise de uma experiência tão avançada com a Bevy, é possível utilizar o <code>DefaultPlugins</code> que utilizamos anteriormente, que possui sistemas como Rendering, gerenciamento de assets, sistema de UI, janelas e gerenciamento de entrada de dados.</p>
<h3 id="criando-um-plugin"><a class="header" href="#criando-um-plugin">Criando um Plugin</a></h3>
<p>Para criar um plugin simplesmente precisamos implementar a trait <code>Plugin</code> em um tipo que comporte as informações necessárias. No caso do plugin que vamos implementar é apenas um <code>hello world</code> para plugins, então não precisamos de dados, criando apenas um </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HelloPlugin;

impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // lógica do plugin
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma função que nosso sistema vai executar, neste caso um simples <code>println</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_plugin() {
    println!(&quot;hello plugin!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>E adicionamos essa função como um <code>startup_system</code> no nosso plugin:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_startup_system(hello_plugin);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, basta adicionarmos nosso plugin ao <code>App</code> principal e executar <code>cargo run</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugin(HelloPlugin)
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre></pre>
<p>Veremos algo no terminal como:</p>
<pre><code>2022-06-20T05:28:52.725036Z  INFO bevy_render::renderer: AdapterInfo { name: &quot;AMD Radeon Pro 5500M&quot;, vendor: 0, device: 0, device_type: DiscreteGpu, backend: Metal }
hello plugin!
</code></pre>
<h1 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity Component System (ECS)</a></h1>
<p>O sistema de gerenciamento de dados da Bevy é chamado de <em>Entity Component System</em>, ou <strong>ECS</strong>, e sua principal característica é a simplicidade do gerenciamento de dados. Uma boa analogia ao seu funcionamento é com bancos de dados tabulares, na qual os componentes, <em>components</em>, são os tipos de dados, ou colunas, e as entidades, <em>entities</em>, são as linhas, mais especificamente o ID das linhas. Por exemplo, você poderia ter diversas entidades com o componente <code>Health</code> e cada entidade possui um component <code>Health</code> diferente, já que NPCs, players e objetos do mundo podem ter <code>Health</code>s diferentes (<em>health</em> significa vida em inglês). Assim, o conjunto de componentes que uma entidade possui é chamado de arquétipo, <em>Archetype</em>.</p>
<p>Considerando a entidade player possuindo componentes como vida, força, ataque, defesa, inventario, as entidades inimigos com vida, força, ataque, defesa, inteligência, e a entidade planta com apenas vida, fica muito fácil escrever uma lógica de jogo que gerencia esses tipos de entidades, como verificar se uma entidade com vida encontrou outra entidade com vida, simplificando muito a criação de lógicas de jogo. Essa lógica de gerenciamento é chamado sistema, <em>system</em>. Estes sistemas são executados em paralelo pelo <em>smart scheduling algorithm</em> da Bevy e com isso devemos manter nossas entidades o mais horizontal possível, evitando grandes componentes com muitos campos. Isso influência muito a performance do sistema, pois quando mais vertical a entidade mais problemas de acesso aos dados em paralelo teremos.</p>
<blockquote>
<p>Para você que vem da orientação a objectos, no paradigma de ECS é mais comum possuir uma entidade com diversos componentes, como a entidade Player que possui os componentes Vida(u32), Posição(x, y, z), Direção(x, y, z), Escala(x, y, z), Rotação(x, y, z), Defesa(u16), Ataque(u16), Força(u16) em vez de uma classe <code>Player</code> com os campos vida: u32, posição: [x, y, z], direção: [x, y, z], escala: [x, y, z], rotação: [x, y, z], defesa: u16, ataque: u16, força: u16:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefira isso:
// Entidade Player;

#[derive(Component)]
pub struct Vida(u32)

#[derive(Component)]
pub struct Posição(x, y, z)

#[derive(Component)]
pub struct Direção(x, y, z)

#[derive(Component)]
pub struct Escala(x, y, z)

#[derive(Component)]
pub struct Rotação(x, y, z)

#[derive(Component)]
pub struct Defesa(u16)

#[derive(Component)]
pub struct Ataque(u16)

#[derive(Component)]
pub struct Força(u16)

// Em vez disso:
pub struct Player {
    pub vida: u32, 
    pub posição: [x, y, z], 
    pub direção: [x, y, z], 
    pub escala: [x, y, z], 
    pub rotação: [x, y, z], 
    pub defesa: u16, 
    pub ataque: u16, 
    pub força: u16,
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="criando-entidades"><a class="header" href="#criando-entidades">Criando entidades</a></h2>
<p>Entidades são simplesmente IDs inteiros associados a um comando <code>spawn</code> de <code>commands</code>, <code>commands.spawn(...)</code> e para adicionar componentes basta utilizarmos a diretica <code>insert</code> em um <code>spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_entity(mut commands: Commands) {
    commands
        .spawn()
        .insert(Label(&quot;Player&quot;))
        .insert(Vida(10))
        .insert(Posição(0, 2, 0))
        .insert(Direção(0, 2, 0))
        .insert(Escala(0, 2, 0))
        .insert(Rotação(0, 2, 0))
        .insert(Defesa(10))
        .insert(Ataque(10))
        .insert(Força(10));
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, existe o conceito de <em>bundles</em>. <em>Bundles</em> são como <em>templates</em> que tornam a criação de entidades com diversos componentes mais simples:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Bundle)]
struct Transform {
    posição: Posição(x, y, z),
    direção: Direção(x, y, z),
    escala: Escala(x, y, z),
    rotação: Rotação(x, y, z),
}

#[derive(Bundle)]
struct Player {
    vida: u32, 
    defesa: u16, 
    ataque: u16, 
    força: u16,

    #[bundle] // Nested bundles
    transform: Transform
}
<span class="boring">}
</span></code></pre></pre>
<p>Como podemos ver em <code>transform: Transform</code>, bundles também podem ser encadeados. Tuplas arbitrárias também são consideradas bundles. Note, que bundles não podem ser consultados com uma <em>query</em>.</p>
<h2 id="recursos-resources"><a class="header" href="#recursos-resources">Recursos (<em>Resources</em>)</a></h2>
<p>Recursos são um tipo de instância que permite armazenar um tipo de dado de forma global, independente de entidades, e qualquer tipo Rust pode ser usado como um recurso independente de implementação de traits. Existem duas formas de inicializar recursos, a primeira é definindo a trait <code>Default</code> para eles, quando eles possuem um tipo de dado simples, já a segunda é implementando a trait <code>FromWorld</code> que permite atuar sobre o recurso utilizando valores de <code>World</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct StartingLevel(usize);

struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS from here.
        // For instance, you can mutate other resources:
        let mut x = world.get_resource_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E para inicializar seus recursos em um App basta usar a função <code>insert_resource</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // Caso implemente uma das traits `Default` ou `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()
        // se for necessário definir o valor inicial
        .insert_resource(StartingLevel(3))
        // ...
        .run();
}
</code></pre></pre>
<p>A decisão de quando usar recursos ou entity/component é baseada na forma e no momento em que este dado vai ser acessado, mas considerando algo como um jogo com uma unica entidade, pode ainda ser útil utilizar o padrão ECS, pois ele permite maior flexibildiade e compartilhamento de dados, que podem ser muito úteis para a evolução do jogo.</p>
<h2 id="sistemas-systems"><a class="header" href="#sistemas-systems">Sistemas (<em>Systems</em>)</a></h2>
<p>Sistemas são funções que a desenvolvedora escreve com o objetivo de ser uma unidade de lógica do jogo atuando sobre as entidades e os componentes. Os sistemas são executados e gerenciados pelas Bevy, mas somente podem ser usados com parâmetros especiais. Os parâmetros especiais são:</p>
<ul>
<li><code>Res/ResMut</code> para acessar recursos.</li>
<li><code>Query</code> para acessar componentes de uma entidade.</li>
<li><code>Commands</code> para criar e destruir entidades, componentes e recursos.</li>
<li><code>EventWriter/EventReader</code> para enviar e receber eventos.</li>
</ul>
<p>Um sistema pode conter no máximo 16 parâmetros, caso seja preciso mais parâmetros pode se agrega-los em tuplas de no máximo 16 parâmetros. Caso estes limites não sejam suficiente, é possível fazer tuplas de tuplas.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    mut c: Option&lt;ResMut&lt;ResourceC&gt;&gt;,
) {
    if let Some(mut c) = c {
        // lógica
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No sistema a cima <code>ResourceA</code> é um recurso imutável e esta compartilhando uma tupla com <code>ResourceB</code>que é um recurso mutável. Já <code>ResourceC</code> é um recurso que pode não existir e por isso está englobado por um tipo <code>Optional&lt;T&gt;</code>.</p>
<p>Existem dois tipos de funções para executar sistemas na Bevy</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // ...
        // sistemas executados apenas quando o App é lançado
        .add_startup_system(init_menu)
        .add_startup_system(debug_start)

        // sistemas executados todos os frames
        .add_system(move_player)
        .add_system(enemies_ai)
        // ...
        .run();
}
</code></pre></pre>
<p>Agora vamos começar a implementar nosso snake game e aprofundar nossos conhecimentos em bevy.</p>
<p><strong>Referência: <a href="https://bevy-cheatbook.github.io/programming.html">unofficial bevy guide</a></strong></p>
<h1 id="a-cabaça-da-cobra"><a class="header" href="#a-cabaça-da-cobra">A Cabaça da Cobra</a></h1>
<p>Para começar o jogo precisamos do primeiro componente, neste caso a cabeça da cobra, que definirá os próximos possíveis passos, assim como para onde os blocos seguintes se moverão. Este primeiro componente se chamará <code>SnakeHead</code> e será uma struct vazia com a trait <code>Compoent</code> associada a ela:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component)]
pub struct SnakeHead;
<span class="boring">}
</span></code></pre></pre>
<p>A função de <code>SnakeHead</code> é basicamente ser um marcador para as entidades do tipo snake, que nos permitirá filtrar as estas entidades quando formos fazer queries com os players. Muitos componentes não precisam de estados e podem funcionar apenas como marcadores, um padrão bastante comum no mundo ECS, já que optamos por uma estratégia de <em>has a</em> (possui um) em vez de <em>is a</em> (é um, da orientação a objetos). Outro detalhe importante é a adição de uma cor ao específica para a cabeça da cobra <code>const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);</code>.</p>
<p>Nosso próximo passo é gerar uma entidade snake, que possui um componente do tipo <code>SnakeHead</code>, e essa entidade pode ser gerada adicionando um sistema incial com <code>add_startup_system(spawn_snake)</code>, dada a função <code>spawn_snake</code>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);

fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_startup_system(spawn_snake)
        .add_plugins(DefaultPlugins)
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}

#[derive(Component)]
pub struct SnakeHead;

fn spawn_snake(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(SnakeHead);
}
</code></pre></pre>
<blockquote>
<p><strong>SpriteBundle</strong></p>
<p><code>SpriteBundle</code> é um tipo de componente que agrega características comuns a uma entidade que utiliza sprites como o proprio sprite (especificidades da imagem), transform (relação de posição, escala e rotação), visibilidade, transform global e o manuseio de imagens. </p>
</blockquote>
<p>Neste caso, não temos nenhuma imagem específica como sprite, mas definimos um transform com uma escala de <code>10 x 10 x 10</code> pixels e uma cor de filtro acinzentada para a região definida pelo transform, as outras propriedades foram definidas como <code>..default()</code>. Ao executarmos <code>cargo run</code> o resultado é algo como:</p>
<p><img src="part-2/../imagens/snake_pixel.png" alt="Entidade snake com SpriteBundle" /></p>
<h2 id="nosso-primeiro-teste"><a class="header" href="#nosso-primeiro-teste">Nosso primeiro teste</a></h2>
<p>No mundo moderno, jogos sem testes estão fadados ao fracasso. Não estou dizendo que todos os jogos possuem uma bateria maravilhosa de testes automatizados, mas desde que escrevi o livro <strong>Lean Game Development</strong> até hoje, o mercado de games AAA mudou muito. Hoje em dia vejo jogos sendo desenvolvidos com TDD e com QA advogando por testes automatizados de gameplay emt todos os sistemas, garantindo uma jogabilidade equilibrada/desejada em qualquer plataforma. Hoje em dia um jogo, middleware, game server ou ferramenta sem nenhum teste esta fadado ao fracasso por conta do número excessivo de bugs e clientes infelizes. Sendo assim, é importante ter uma noção de como testar minimamente seus sistemas com a Bevy. Sendo assim, vamos aprender a escrever o teste mais simples possível, verificar se nosso sistema <code>spawn_snake</code> de fato adiciona um compoente <code>SnakeHead</code> a entidade desejada.</p>
<p>Primeiro passo do teste será mover tudo que é relacionado a <code>snake</code> para um módulo chamado <code>snake.rs</code>:</p>
<p><strong><code>main.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

mod snake;

use snake::spawn_snake;

fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_startup_system(spawn_snake)
        .add_plugins(DefaultPlugins)
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<p><strong><code>snake.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;

const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);

#[derive(Component)]
pub struct SnakeHead;

pub fn spawn_snake(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(SnakeHead);
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora em Snake vamos criar um teste dentro de um módulo de testes (<code>#[cfg(test)] mod test {...}</code>) que verifique se um componente <code>SnakeHead</code> está presente:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn entity_has_snake_head() {
        // 1 Inicialização do App
        let mut app = App::new();

        // 2 Adicionar o `spawn_snake` startup system
        app.add_startup_system(spawn_snake);

        // 3 Executar todos os sistemas pelo menos uma vez
        app.update();

        // 4 Fazer uma query por entidades que contenham o componente `SnakeHead`
        let mut query = app.world.query_filtered::&lt;Entity, With&lt;SnakeHead&gt;&gt;();

        // 5 Verificar se a contagem de componentes da query foi igual a 1
        assert_eq!(query.iter(&amp;app.world).count(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Descrevendo o teste <code>entity_has_snake_head</code> (verifica se entidade possui componente snake head) temos como primeiro passo (<code>1</code>) criar um <code>App</code> mutável para podermos adicionar sistemas como o <code>spawn_snake</code> (<code>2</code>) e executarmos todos os sistemas pelo menos uma vez com <code>app.update()</code> (<code>3</code>). Próximo passo é realizarmos uma <code>query</code> (<code>4</code>) no sistema de ECS para procurarmos por uma entidade que possua o componente <code>SnakeHead</code> (<code>With&lt;SnakeHead&gt;</code>). Com o resultado desta <code>query</code> verificamos se a quantidade de entidades que possuam o componente <code>SnakeHead</code> é igual a <code>1</code> (<code>5</code>).</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>O principal objetivo de queries é nos permitir acessar componentes de entidades. No código a seguir, temos uma query do tipo <code>Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;</code> que representa todas as entidades que possuam <code>Health</code> e <code>Transform</code>, com a propriedade <code>Health</code> sendo apenas leitura e a propriedade <code>Transform</code> sendo mutável. Além disso, caso o componente <code>Player</code> esteja presente, permite leitura a ele. Depois disso iteramos sobre todos os ítens dessa query, de forma mutável, para podermos alterar a propriedade transform, <code>(health, mut transform, player) in query.iter_mut()</code>. Por último, caso o componente <code>Player</code> esteja presente, sabemos que está entidade é do tipo player e aplicamos uma lógica extra.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_zero_health(
    mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
    // Obtem todas as entidades do tipo
    for (health, mut transform, player) in query.iter_mut() {
        eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);

        // centraliza se `hp` é menor ou igual a `0.0`
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::ZERO;
        }

        if let Some(player) = player {
            // entidade é do tipo `Player`
            // lógica extra
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>para obter o ID de uma entidade com queries basta adicionar <code>Entity</code> a query e a variável <code>entity_id</code> correspodnerá ao id:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// adicione `Entity` a `Query` para obter os IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (entity_id, /* ... */) in q.iter() {
        // `entity_id` é o ID da entidade que estamos acessando.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Caso exista certeza que uma query vai identificar apenas uma entidade, é possível utilizar <code>single</code> e <code>single_mut</code> para acessar seus componentes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
    let (player, mut transform) = q.single_mut();
    // lógica
}
<span class="boring">}
</span></code></pre></pre>
<p>Outro recurso interessante de queries são os <em>Query Filters</em>, um tipo especial de queries que permite reduzir a quantidade de entidade que uma query retorna. <em>Query filters</em> se utilizam dos filtros <code>With</code> e <code>Without</code> para garantir que a entidade tenha (<code>With</code>) ou não tenha (<code>Without</code>) certos componentes. No exemplo a seguir, a query acessa todas as entidades com o componente <code>Health</code> que sejam  <code>Players</code> amigáveis e que opcionalmente possuam <code>PlayerName</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_player_hp(
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    for (health, name) in query.iter() {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Utilizando filtros</strong></p>
<ul>
<li>Elementos adicionados em uma Tupla, como <code>(With&lt;Player&gt;, Without&lt;Enemy&gt;)</code>, são considerados <code>AND</code>/<code>E</code> lógicos.</li>
<li>Para utilizar <code>OR</code>/<code>OU</code> lógicos é preciso envolver as tuplas em um filtro do tipo <code>Or&lt;(…)&gt;</code>.</li>
</ul>
</blockquote>
<h2 id="movendo-a-cabeça-da-cobra"><a class="header" href="#movendo-a-cabeça-da-cobra">Movendo a cabeça da cobra</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
