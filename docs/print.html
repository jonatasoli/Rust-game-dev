<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento de Jogos online com Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-quemsou.html"><strong aria-hidden="true">1.1.</strong> Quem sou eu? (Sobre a autora)</a></li></ol></li><li class="chapter-item expanded "><a href="part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Conceitos Básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predição e Reconciliação</a></li><li class="chapter-item expanded "><a href="part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpolação de Entidades</a></li><li class="chapter-item expanded "><a href="part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensacão de Lag</a></li></ol></li><li class="chapter-item expanded "><a href="part-2/00-intro.html"><strong aria-hidden="true">3.</strong> Multiplayer Snake Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-2/01-bevy.html"><strong aria-hidden="true">3.1.</strong> Sobre a Bevy</a></li><li class="chapter-item expanded "><a href="part-2/02-ecs.html"><strong aria-hidden="true">3.2.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="part-2/03-cabeca.html"><strong aria-hidden="true">3.3.</strong> A Cabeça da Cobra</a></li><li class="chapter-item expanded "><a href="part-2/04-grid.html"><strong aria-hidden="true">3.4.</strong> Grade de Movimento</a></li><li class="chapter-item expanded "><a href="part-2/05-spawnfood.html"><strong aria-hidden="true">3.5.</strong> Gerador de Comidas</a></li><li class="chapter-item expanded "><a href="part-2/06-cadencia.html"><strong aria-hidden="true">3.6.</strong> Melhorando a Cadência do Movimento</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="desenvolvimento-de-jogos-online-com-rust"><a class="header" href="#desenvolvimento-de-jogos-online-com-rust">Desenvolvimento de Jogos Online com Rust</a></h1>
<p>Por Julia Naomi Boeira.</p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<p>Escrever um livro open source é um trablho que precisa de incentivo e por isso Github Sponsor e Patreon são coisas importantes, pois além de atuarem como incetivo, são um bomr econhecimento do nosso trabalho. Escrevi bastantes livros pela casa do código, mas em especial no assunto Rust e Games eu sinto que falta alcance, e por isso gostaria de continuar produzindo esse tipo de material.</p>
<h2 id="sobre-o-livro"><a class="header" href="#sobre-o-livro">Sobre o livro</a></h2>
<p>Até o momento planejei 3 partes para este livro:</p>
<ol>
<li><a href="part-1/00-capa.html">Conceitos Básicos</a>, onde vamos falar sobre como funciona um jogo online e quais são suas limitações.</li>
<li>Jogo da cobrinha com a engine Bevy, essa é a parte menos criativa do processo e é uma cópia traduzida deste tutorial <a href="https://mbuffett.com/posts/bevy-snake-tutorial/">Bevy Snake Tutorial</a>. A diferença é que vou adicionar elementos de um jogo multiplayer local.</li>
<li>Servidor autoritário com a Bevy.</li>
</ol>
<p>ESPERO QUE APROVEITEM A LEITURA e feedbacks são bem vindos. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quem-sou-eu"><a class="header" href="#quem-sou-eu">Quem sou eu</a></h1>
<p>Eu sou uma desenolvedora de jogos na Ubisoft Winnipeg atuando no desenvolvimento de sistemas online, middlewares e ferramentas para jogos. Trabalho principalmente com C++, mas um pouco de C# e Rust. Sou autora dos livros:</p>
<ul>
<li>📖 <a href="https://www.apress.com/gp/book/9781484232156">Lean Game Development - Inglês - Apress</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-lean-game-development">Lean Game Development - Português - Casa do Código</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-rust-funcional-concorrente">Programação Funcional e Concorrente em Rust - Casa do Código</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-tdd-games">TDD para Games - Casa do Código</a></li>
<li>📖 <a href="https://github.com/naomijub/web-dev-rust-book">[OPEN SOURCE] Desenvolvimento Web com Rust</a></li>
</ul>
<p>E atualmente estou desenvolvendo em paralelo a este livro o livro <a href="https://github.com/naomijub/Unity-FPS-game-with-TDD-Book">Unity FPS game with TDD - Inglês</a>.</p>
<p>Tenho atuado como evangelista voluntaria de Rust desde 2017 quando me deparei com Rust pela primeira vez e percebi que esta maravilhosa linguagem era um raio de esperança nos problemas que eu tinha no desenvolvimento de jogos com C++.</p>
<p>Hobbies como engenheira são aprender novas linguagens, em especial de paradigmas diferentes ou que pelo menos possuem uma forma bem diferente de resolver problemas, tornando Clojure e Elixir minhas duas outras linguagens favoritas. E no meu tempo livre escrever e fazer prototipos bobos de jogos como esses (quando eu estava aprendendo Java) https://github.com/naomijub/DiammondSeek e https://github.com/naomijub/PacmanLabyrinth.</p>
<p>Curiosidade sobre aprender linguagens de programação, tentei aprender Java na faculdade, mas simplesmente não entrava na minha cabeça, foi graças a XNA e aos C# que consegui aprender Java e arrumar trabalho com software corporativo. Tentei aprender Go 3 vezes e NUNCA entra na minha cabeça. Trabalhei muito com Python a ponto de dizer que era uma das minhas linguagens favoritas, mas hoje em dia eu fujo de qualquer projeto Python.</p>
<p>Passei pelas faculdades de Matematica Aplicada, Engenharia de Materiais e Ciências da Computação. Larguei a CC porque já estava cursando mestrado em inteligência artificial aplicada a engenharia de materiais e depois aiinda fiz especialização em desenvolvimento de jogos para suprir as áreas que faltavam do meu conhecimento em jogos. A empresa que mais gostei de trabalhar é a Ubiisoft DE WINNIPEG, mas outras empresas que gostei muito foram a Thoughtworks até 2018, onde conheci pessoas incríveis que são minhas amigas até hoje, e Nubank que foi um lugar de muito aprendizado.</p>
<p>Para dúvidas sobre o livro, discussões sobre o tema e correções sugiro abrir <a href="https://github.com/naomijub/Rust-game-dev/issues">issues</a> ou criar <a href="https://github.com/naomijub/Rust-game-dev">Pull Requests</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais"><a class="header" href="#conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais">Conceitos importantes para o desenvolvimento de serviços de jogos digitais</a></h1>
<ol>
<li>O problema e sua arquitetura básica.</li>
<li>Predição e reconciliação.</li>
<li>Interpolação de entidades.</li>
<li>Compensação de lag.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="o-problema-e-sua-arquitetura-básica"><a class="header" href="#o-problema-e-sua-arquitetura-básica">O problema e sua arquitetura básica.</a></h1>
<p>Neste capítulo vamos entender quais os problemas que serviços para games enfrentam e quais são algumas das formas de resolvê-los para obtermos um conjunto de serviços que tornam o desenvolvimento de jogos multiplayer uma realidade. </p>
<blockquote>
<p><em>Multiplayer</em></p>
<p>Jogos multiplayer são jogos com mais de uma pessoa jogando simultaneamente se conectando através de um servidor.</p>
</blockquote>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Desenvolver um jogo é bastante complicado, agora desenvolver um jogo para mais de uma pessoa jogando é ainda mais complicado. Felizmente, podemos resumir os problemas que servidores de jogos possuem em duas categorias:</p>
<ol>
<li>Humanos maliciosos.</li>
<li>Física realística.</li>
</ol>
<h3 id="humanos-maliciosos"><a class="header" href="#humanos-maliciosos">Humanos Maliciosos</a></h3>
<p>Tudo começa com o desejo das pessoas de trapacear em um jogo.</p>
<p>Podemos dizer que para jogos single-player, ou de somente uma pessoa jogando, trapacear afeta a experiência, mas é uma escolha da pessoa burlar a experiência do jogo, a final a trapaça não afeta ninguém além da pessoa, porém para jogos multiplayer o cenário é diferente. Em um jogo multiplayer, uma pessoa burlando as regras do jogo pode conseguir algumas vantagens que além de afetar sua experiência, tornam a experiência das outras pessoas muito pior. Alguns exemplos que já vi na minha vida:</p>
<ul>
<li>Vida muito maior que 100%, ou seja, a pessoa possuia 1000% de vida em uma partida, tornando ela quase imortal, já que colecionava muito mais recursos.</li>
<li>Tiros duplos ou triplos, ou seja, para cada vez que a pessoa realizava um tiro, duas ou três balas eram enviadas ao mesmo tempo, reduzindo muito as chances do alvo de sobreviver.</li>
<li>Atravessar paredes, não sei bem como este mod funcionava, mas acredito que projetava a pessoa para além do objeto de colisão.</li>
<li>Paredes invisíveis, ou seja, a pessoa havia removido a renderização de objetos inanimados, o que a permitia visualizar todos os alvos antes de ser percebida.</li>
<li>Velocidade 2, ou seja, para cada passo da pessoa, o jogo a movia 2 vezes mais rápido.</li>
</ul>
<p>Tendo estes eventos em mente, podemos concluir que existe uma única solução realmente confiável para um servidor NÃO CONFIAR NO USUÁRIO.</p>
<h2 id="como-não-confiar-no-usuário"><a class="header" href="#como-não-confiar-no-usuário">Como não confiar no usuário?</a></h2>
<p>A resposta para está pergunta é na verdade bastante simples, o cliente, ou seja a pessoa jogando, deve fornecer o mínimo de informações em relação ao seu posicionamento, balas disparadas, direção, etc. Enquanto isso, o servidor deve ser autoritário, recendendo estes comandos básicos e informado para o cliente o que está acontecendo. Em outras palavras, o cliente envia comandos e botões pressionados para o servidor, o servidor executa o próximo passo do jogo e devolve ao cliente as novas informações. Isso não vai impedir que o servidor seja explorado de vulnerabilidades, mas reduzirá drasticamente a capacidade de uma pessoa jogando de trapacear. Assim, para o caso da pessoa que está dando tiros múltiplos, ela pode até ver 3 tiros saindo de sua arma, mas o servidor reconhecerá somente 1 e propagará ao resto do jogo somente 1. </p>
<p>Resumindo, o gerenciamento do estado do jogo é realizado apenas pelo servidor. Clientes enviam apenas suas interações com o controle, teclado e mouse para o servidor. O servidor atualiza o estado do jogo e envia esta informação de volta aos clientes que apenas renderizam ela em sua tela.</p>
<h2 id="o-problema-com-a-física"><a class="header" href="#o-problema-com-a-física">O problema com a física</a></h2>
<p>Parece uma solução perfeita né? Infelizmente ela funciona bem somente quando o jogo é baseado em turnos, como jogos de carta e alguns RPGs, ou a rede é em LAN, já que neste cenário a comunicação com o servidor é considerada instantânea. Para jogos como Call of Duty e Rainbow Six está estratégia vai contar com um enorme delay já que precisam se conectar com servidores distantes.</p>
<p>Assim, vamos supor o meu cenário. Mesmo que minha conexão à internet seja sensacional (mentira, isso não existe), estou em Porto Alegre e o servidor mais próximo está em São Paulo para o jogo X. Porto Alegre e São Paulo estão distantes entre si mais de 1100 km. Na física a velocidade da luz é a maior velocidade atingível por um corpo (photons no caso), ou seja 300.000 km/s no vácuo, assim a luz levaria 3,7 milisegundos para percorrer os 1100 km (1100/300000 = 0,0036667 segundos). Essa é a velocidade da luz no vácuo, parece bem otimista né? Mas neste caso estamos falando de bytes trafegando pela internet, que na prática são elétrons e pulsos de luz trafegando por um cabo, e provavelmente não em linha reta, o que deve aumentar esse valor de 3,7 por alguns microsegundos. Existe mais um fator importante em como a internet funciona, os dados trafegados pela internet são na verdade uma séries de pacotes, ou <em>hops</em>, que trafegam de um roteador ao outro, certamente abaixo da velocidade da luz. Além disso, roteadores possuem um atraso extra, já que todos os pacotes devem ser abertos, copiados e inspecionados para então serem reroteados a seus destinos finais.</p>
<p>Vamos então dizer que o atraso dos meus pacotes até São Paulo leva 25 ms, o que seria um tempo excepcional (neste momento um ping da minha máquina ao google.com está levando entre 25 e 30 ms), mas tempos de 50 ms e até 200 ms não seria impressionantes para certas situações. Agora vamos dizer que nossa jogadora apertou para atirar no momento x, isso quer dizer que nosso servidor receberá a ação de atirar 25 ms depois. Digamos que nosso servidor processe o evento em um tempo substancialmente menor que 1 milisegundo, algo como 500 us, isso quer dizer que quando o servidor responder, a jogadora receberá essa atualização 50 ms depois de ter clicado para atirar. Humanos em média enxergam 25 frames por segundo, o que indica que o delay já é maior que nossa capacidade de observação por 10 ms. Esses 10 ms de delay na nossa percepção já são suficiente para termos uma experiência ruim de jogabilidade, ou seja, o famoso <em>lag</em>, ou atraso. A imagem a seguir demonstra este efeito:</p>
<p><img src="part-1/../imagens/ping_time.jpg" alt="Diagrama de atraso na conexão cliente servidor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predição-e-reconciliação"><a class="header" href="#predição-e-reconciliação">Predição e Reconciliação</a></h1>
<p>No capítulo anterior falamos sobre o lag, ou atraso entre ação no cliente e a atualização enviada pelo servidor nos baseando no modelo de cliente servidor na qual o cliente não responde seu estado, mas sim a ação desejada, para que o servidor atualize seu estado. Um jogo que pode levar algumas frações de segundo para atualizar o estado pode ser considerado de jogabilidade ruim ou injogável devido ao lag de renderização. Assim, neste capítulo vamos explorar uma solução para minimizar este problema.</p>
<h2 id="predição-pelo-lado-do-cliente"><a class="header" href="#predição-pelo-lado-do-cliente">Predição pelo lado do cliente</a></h2>
<p>Como a maior parte dos jogos é deterministico, ou seja, não há aleatoriedade no resultado, podemos prever qual vai ser o próximo passo do jogo antes do servidor responder. Para maior parte das pessoas jogando esta experiência será &quot;idêntica&quot; ao jogo sem servidor, mas para as pessoas trapaceando a experiência não será realistica, desfavorecendo o jogo com trapaças. Assim, podemos assumir que nosso servidor receberá ações válidas para 99% dos casos, nos permitindo prever o próximo instante.</p>
<p>No cenário que descrevemos anteriormente nossa ação com o servidor levava 50 ms para atualizar o estado do jogo, para só então uma animação ser ativada (digamos que ela leve mais 50 ms) como a imagem a seguir nos mostra:</p>
<p><img src="part-1/../imagens/animation_time.jpg" alt="Diagrama de atraso na conexão cliente servidor com tempo de animação" /></p>
<p>Nessa imagem podemos ver que o atraso do servidor (50 ms) mais o tempo de animação (50 ms) fará com que percebemos o tiro apenas 100 ms depois dele ter sido realizado, ou seja, no terceiro frame que nosso olho detecta, certamente uma experiência desagradável. </p>
<p>Como o jogo nosso jogo é deterministico, podemos presumir que a ação será executada com sucesso no servidor, aplicar nossas regras locais de validação e iniciar a animação do tiro no momento em que pressionamos o botão para realizar a ação. Para a grande maioria dos casos a atualização do servidor e o final da animação vão coincidir em estado e fizemos um predição bem sucedida, fazendo com que não exista atrasos entre a ação e a renderização. Para os casos de trapaça a animação ocorrerá, mas em nada afetará o estado geral do jogo, somente afetará negativamente a experiência do usuário trapacendo.</p>
<h3 id="problemas-de-sincronização"><a class="header" href="#problemas-de-sincronização">Problemas de sincronização</a></h3>
<p>Infelizmente essa estratégia não é perfeita e problemas de sincronização ou eventos conflitantes podem acontecer. Imagine agora o cenário na qual o personagem está se movimentando e o tempo de atraso é 75 ms em vez dos 50 ms anteriores, o tempo da animação é de 30 ms e a pessoa pressiona para se movimentar para frente 2 vezes seguidas. A imagem a seguir e os passos marcados na imagem exemplificam:</p>
<p><img src="part-1/../imagens/sync_problem.jpg" alt="Diagrama com problemas de sincronização de ações" /></p>
<ol start="0">
<li>Personagem está o ponto <code>(0,0)</code> no instante 0 ms.</li>
<li>Neste mesmo instante a pessoa pressiona para se movimentar enviando uma ação para o servidor que durará 75 ms.</li>
<li>A ação do passo 1 ativou uma animação que moveu o personagem para a posição <code>(0,1)</code> 30 ms depois.</li>
<li>Na posição <code>(0,1)</code> uma nova ação de movimentação acontece, enviando esta nova ação para o servidor que durará mais 75 ms.</li>
<li>A ação do passo 3 ativou uma nova animação que moveu o personagem para a posição <code>(0,2)</code> 30 ms depois. Já se passaram 60 ms.</li>
<li>15 ms depois de terminar a ação 4, o servidor respondeu a ação 1 fazendo o personagem voltar para posição <code>(0,1)</code>. Já se passaram 75 ms.</li>
<li>30 ms depois de terminar a ação 5, o servidor respondeu a æção 3 fazendo o personagem voltar para posição <code>(0,2)</code>. Ja se passaram 105 ms.</li>
</ol>
<p>Com este detalhamento podemos ver que pelo ponto de vista da pessoa jogando, o personagem vai responder as duas primeiras ações se movimentando até a posição <code>(0,2)</code> para então voltar para posição <code>(0,1)</code> e depois ainda voltar para posição <code>(0,2)</code> gerando uma péssima experiência de jogo, forçando assim a adotarmos uma estratégia de reconciliação.</p>
<h2 id="reconciliacão-pelo-servidor"><a class="header" href="#reconciliacão-pelo-servidor">Reconciliacão pelo servidor</a></h2>
<p>A chave deste problema é entender a diferença temporal dos cliente e do servidor, já que o cliente vê o jogo em tempo real (presente) e o servidor autoritário está no passado. Assim, sempre haverá uma diferença de sequência de comandos a serem processados entre o cliente e o servidor. Felizmente isso não é muito difícil de resolver.</p>
<p>Primeiro passo é fazer com que o cliente salve suas ações em uma sequência de comandos, assim a primeira movimentação seria a ação <code>#1</code> e a segunda movimentação seria a ação <code>#2</code>. Logo, o servidor poderá respoderá responder uma ação identificando a qual comando ela pertence. A figura a seguir exemplifica o que acontece:</p>
<p><img src="part-1/../imagens/reconciliacao.jpg" alt="Diagrama de reconciliação de ações" /></p>
<ol>
<li>O evento <code>#1</code> é lancado, 30 ms depois da animação a posição <code>#1 =&gt; (0,1)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#1</code>. A sequência de comandos é <code>[#1 =&gt; (0,1)]</code>.</li>
<li>O evento <code>#2</code> é lancado, 30 ms depois da animação a posição <code>#2 =&gt; (0,2)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#2</code>.  A sequência de comandos é <code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>.</li>
<li>O evento <code>#1</code> é retornado pelo servidor com o valor <code>#1 =&gt; (0,1)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>) e o evento <code>#1 =&gt; (0,1)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#1 =&gt; (0,1)</code> da sequência de comandos.</li>
<li>O evento <code>#2</code> é retornado pelo servidor com o valor <code>#2 =&gt; (0,2)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#2 =&gt; (0,2)]</code>) e o evento <code>#2 =&gt; (0,2)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#2 =&gt; (0,2)</code> da sequência de comandos.</li>
<li>Sequência de comandos é <code>[]</code>.</li>
</ol>
<blockquote>
<p><strong>Descrição da função <code>check</code></strong></p>
<ol>
<li>Argumentos são <strong>sequência de comandos executados</strong> e <strong>evento #</strong>.</li>
<li>Verifica se o valor de <code>#n</code> na sequência de comando é igual ao que o servidor retornou. Caso não for igual retorna erro.</li>
<li>Aplica o próximo evento, <code>#n+1</code>, ao resultado do evento <code>#n</code>. Caso o resultado de <code>#n</code> mais o evento <code>#n+1</code> não corresponder ao evento salvo na sequência de comandos para <code>#n+1</code> retornar erro.
<strong>Observação</strong>: Se o evento que o servidor responder não for <code>#n</code> esperado, podemos concluir que o pacote se perdeu ou o servidor retornou um erro, assim existem duas alternativas <strong>1.</strong> descartar todos os pacotes até o evento recebido e fazer o check, ou <strong>2.</strong> aplciar todos os eventos anteriores até o evento recebido. Particularmente vejo a soluação <strong>1</strong> sendo a mais comum, pois sabemos que o estado anterior está certo.</li>
</ol>
</blockquote>
<p>Este é um exemplo bem simples de movimentação e bastante intuitivo de visualizar, mas as aplicações de predição e reconciliação podem ser feitas em praticamente qualquer área do jogo e qualquer tipo de jogo. Imagine um jogo de corrida multiplayer e você está na linha de chegada em velocidade máxima, com um carro logo atrás de você. No próximo segundo considerando as atuais circunstâncias, é óbvio que você vai ganhar, pois você está na frente do outro carro e com uma velocidade maior, mas agora imagine que alguns milésimos antes do final da corrida a outra pessoa apertou o botão de nitro e te ultrapassou. A predição diria que seu carro ganharia a corrida, mas o servidor disse que não e você ficou em segundo lugar. Isso nos leva a um ponto interessante, mesmo em ambientes determinísticos, existe a chance da predição e da reconciliação não serem iguais, Para um cenário de fim de jogo como descrito aqui é bastante trivial a resposta, ignore a predição e responda com o resultado do servidor, porém se isso acontecer frequentemente no meio do jogo a experiência de jogabilidade vai ser ruim.</p>
<p>No próximo capítulo vamos explorar como resolver este problema de predição e reconciliação através de interpolação de entidades.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpolação-de-entidades"><a class="header" href="#interpolação-de-entidades">Interpolação de Entidades</a></h1>
<p>Nos capítulos anteriores lidamos com o problema de uma pessoa poder trapacear e como fazer com que o jogo se mantenha conciliado com um servidor autoritário dando a sensação de que o servidor não existe, porém não expandimos este problema para quando estamos lidando com mais de uma pessoa jogando online. Neste capítulo vamos explorar técnicas que nos permitem manter a jogabilidade quando várias pessoas estão interagindo umas com as outras em um ambiente online.</p>
<h2 id="lidando-com-centenas-de-ações-simultâneas"><a class="header" href="#lidando-com-centenas-de-ações-simultâneas">Lidando com centenas de ações simultâneas</a></h2>
<p>No capítulo anterior falamos sobre o servidor processar uma sequência de comandos e retornar como eventos autoritários para o cliente. Imagine agora que este cliente está alucinadamente mandando eventos para o servidor e que ele não está sozinho, pois existem mais uma dezena de clientes mandando eventos simultaneamente para o servidor. Sendo assim, atualizar o estado do jogo para cada comando recebido de cada cliente e depois transmitir o estado do jogo de volta para cada cliente consumiria muita CPU e muita banda.</p>
<p>Tendo em vista evitar o consumo desnecessário de CPU e banda outra abordagem parece fundamental. Esta nova abordagem consiste em enfileirar os comandos que os clientes enviam, sem processar eles, e em vez de atualizar o estado do jogo imediatamente para cada comando, fazemos atualizações periódicas e de baixa frequência, por exemplo 10 vezes por segundo. Este atraso entre cada update, no caso do nosso exemplo de 100 ms, é chamado de <em>time step</em>, ou passo temporal. O <em>time step</em> é definido como uma iteração de loop de update na qual todas as informações não processdas de todos clientes são aplicadas e o novo estado é transmitido para todos os clientes. Ou seja, o estado do jogo é atualizado com uma periodicidade específica de forma independente e não é afetado pela quantidade de clientes e seus comandos.</p>
<p><strong>Obs</strong>: Muitas vezes a física do jogo é atualizada em passos de tempo menor para aumentar a previsibilidade.</p>
<h2 id="updates-de-baixa-frequência"><a class="header" href="#updates-de-baixa-frequência">Updates de baixa frequência</a></h2>
<p>Seguindo com o conceito de um update de estado a cada 100 ms um novo problema aparece, os outros clientes não tem ideia de como seus oponentes estão se atualizando, gerando eventos que parecem bastante bruscos a cada atualização. Ou seja, predição e reconciliação funcionam muito bem para o lado do cliente, mas não para o resto das pessoas jogando. A imagem a seguir detalha melhor essa situação:</p>
<p><img src="part-1/../imagens/step_time.jpg" alt="Diagrama de efeitos do step time para dois clientes" /></p>
<p>Na imagem anterior podemos ver o mesmo cenário de predição e reconciliação funcionando muito bem para o <code>Cliente 1</code>, permitindo que sua jogabilidade seja coerente com a jogabilidade de um jogo single-player, porém para o <code>Cliente 2</code> podemos ver que as transições <code>(0,0) -&gt; (0, 1)</code> e <code>(0, 1) -&gt; (0, 2)</code> do <code>Cliente 1</code> são bruscas para o <code>Cliente 2</code>, já que estas atualizações dependem exclusivamente das atualizações do servidor.</p>
<p>Agora voltando ao exemplo dos carros que mencionamos no final do capítulo anterior. Estamos em uma situação na qual temos controle do nosso carro, mas o carro da outra pessoa é determinado pelo servidor. Se este carro recebe atualizações apenas a cada 100 ms, teremos uma animação péssima de seu deslocamento, nos obrigando a encontrar outra solução para melhorar a experienência. Esta outra soluação envolve fazer a predição da posição do outro carro do lado do nosso cliente, pois sabemos sua direção, sua velocidade e temos certeza que o carro não fará um movimento radical, como girar 180 graus. Sendo assim, se o outro carro está indo reto com uma velocidade de 100 km/h, podemos prever que nos próximos 100 ms o carro estará 0,2 metros a frente de onde ele está neste exato segundo. Essa predição pode parecer maravilhosa, já que ele só se deslocou 0,2 metros em linha reta, mas infelizmente 100 ms é tempo suficiente para muitas outras coisas acontecerem como uma curva aparecer, bater em um poste, desacelerar ou até mesmo frear bruscamente. Chamamos está técnica de <strong>dead reckoning</strong>. Portanto, o <strong>dead reckoning</strong> é uma técnica de predição dos movimentos de outras pessoas em jogos na qual sua posição, velocidade e direção não são afetadas de forma instantânea, permitindo uma pequena margem para prever movimentos sem grandes danos à experiência. Caso alguma ação inesperada aconteça aceitamos que vamos conviver com uma cena estranha.</p>
<blockquote>
<p><strong>Dead reckoning</strong> é originalmente uma estratégia militar para prever a próxima localização de um navio, que se move lentamente e sem grandes oscilações de direção, para que se possa prever onde um torpedo precisa ser lançado para acertar o navio.</p>
</blockquote>
<h2 id="e-para-cenários-muito-dinâmicos"><a class="header" href="#e-para-cenários-muito-dinâmicos">E para cenários muito dinâmicos?</a></h2>
<p>Como falamos anteriormente, <em>dead reckoning</em> é bom para jogos que não são tão dinâmicos, como jogos de corrida, porém para jogos na qual as pessoas jogando se movimentam constantemente, atiram, se abaixam, pulam, giram 180 graus é impossível prever o próximo passo da pessoa apenas com dados anteriores. Se aplicássemos dead reckoning em um jogo de tiro veríamos personagens se teletransportando pequenas distâncias, múltiplas balas saindo de diferentes lugares e personagens fazendo movimentos impossíveis. Sendo assim, outra estratégia é necessária para jogos de tiro, sendo essa a <strong>interpolação de entidades</strong>.</p>
<p>No cenário descrito do parágrafo anterior, temos certeza apenas de 1 coisa, que a cada 100 ms temos uma atualização das informações do estado do jogo e dos personagens. Tendo em vista que sabemos o passado todo, o truque é mostrar para pessoa jogando o que acontece entre esses dados que já sabemos. Ou seja, a solução é mostrar para a pessoa que está jogando o passado relativo dos outros personagens. Isso que chamamos de <strong>interpolação de entidades</strong>.</p>
<p>Explicando melhor, podemos dizer que no momento <code>t = n + 1</code>, que você acabou de receber, a posição do momento <code>t = n</code> é conhecida. Sendo assim, neste momento <code>t = n + 1</code> conhecemos as posições referentes a <code>t = n</code> e <code>t = n + 1</code>. Portanto, para o momento <code>t = n + 2</code> mostramos o passado, ou seja, o que ocorreu no momento <code>t = n = 1</code> e para o momento <code>t = n + 1</code> mostramos o que ocorreu no momento <code>t = n</code> do outro personagem. Deste modo o servidor está sempre mostrando as informações reais de movimentação dos outros personagens, porém com um &quot;pequeno atraso&quot; de 100 ms. A imagem a seguir exemplifica:</p>
<p><img src="part-1/../imagens/interpolation.jpg" alt="Diagrama de interpolação" /></p>
<p>O diagrama de interpolação nos mostra bem como estamos prevendo os passos intermediários. Para um momento inicial estamos com a posição <code>P(0,1)</code>, depois o servidor nos atualiza com a posição <code>P(0,1)</code> novamente, neste momento exibimos a posição que conheciamos antes do <em>step time</em>, a <code>V(0,1)</code>. Quando recebemos a posição <code>P(0,2)</code>, mantemos a posição <code>V(0,1)</code>, que havia sido entregue anteriormente pelo servidor. Agora sabemos o vetor de posições <code>[P(0, 1), #1 P(0, 1), #2 P(0, 2)]</code>, e podemos interpolar que no próximo <em>step time</em> nosso personagem inimigo vai para a posição <code>V(0,2)</code> passando pela posição <code>V(0,1.75)</code>, melhorando a experiência da pessoa jogadora.</p>
<p>Na maior parte dos casos interpolação funciona muito bem, porém existem alguns casos que pode ser importante enviar mais informações de posições intermediárias entre <code>#1</code> e <code>#2</code>. Ou seja, se atualizações de estado a cada 100 ms não são suficientes, podemos enviar as últimas 10 atualizações que ocorreram com intervalos de 10 ms, que certamente vai fazer com que seu jogo pareça mais realista. Note que está técnica faz com que cada jogadora perceba pequenas variações do ambiente do jogo em relação às outras pessoas, que geralmente não é algo perceptível. Infelizmente, nada é perfeito e existem exceções como no caso de quando damos um tiro, pois estamos atirando na personagem da outra pessoa de 100 ms atrás. É nesse caso que precisamos explorar o último tópico desta parte, compensação de lag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compensacão-de-lag"><a class="header" href="#compensacão-de-lag">Compensacão de Lag</a></h1>
<p>O cenário que temos até agora parece funcionar muito bem para percebermos movimentações, pois temos:</p>
<ul>
<li>Dado um tempo n, nosso servidor recebe informações de todos os clientes.</li>
<li>Servidor processa todas as informações e transmite as atualizações.</li>
<li>Estas atualizações são periódicas e de baixa frequência.</li>
<li>Clientes enviam informações e verificam seus efeitos localmente.</li>
<li>Clientes recebem as atualizações de estado do jogo:
<ol>
<li>Reconciliam com os efeitos que previram.</li>
<li>Interpolam os efeitos dos outros personagens.</li>
</ol>
</li>
<li>Cliente se vê no presente, mas vê os outros cliente no passado.</li>
</ul>
<p>Esta situação é geralmente ótima, a menos quando precisamos garantir situações como um tiro na cabeça, que qualquer pequena variação pode causar um erro, pois as informações de tempo e espaço são muito sensíveis. É ai que entra a compensação de lag.</p>
<p>Imagine o cenário na qual você é uma sniper mirando perfeitamente na cabeça de um personagem &quot;imóvel&quot;, um tiro dificil de errar. Você atira e, magicamente, nada acontece. Você se irrita, sai da partida e desliga o jogo pensando como pode ter errado aquele tiro perfeito e, pior, a pessoa que você devia ter matado te matou. Este é o efeito de lag temporal, pois seu tiro ocorreu em um personagem que estava 100 ms no passado, para quem gosta de física, é como se a velocidade da luz fosse muito muito muito inferior a que realmente é. Felizmente, existem algumas estratégias para resolver este efeito. Vamos detalhar como isso pode ser reolvido:</p>
<ol>
<li>Você deu um tiro, seu cliente enviou as informações para o servidor, mas desta vez enviou mais informações além do botão que você clicou, pois enviou o botão que você apertou, o exato momento temporal que você apertou o botão (e se o botão de mira estava sendo apertado) e o que estava exatamente em sua mira neste instante.</li>
<li>Como o servidor está recebendo todos momentos temporais, ele pode reconstruir os eventos temporalmente ordenados, ou seja, o servidor pode reconstruir o mundo no exato momento de seu tiro, assim como para todos outros clientes.</li>
<li>Sabendo o que sua arma estava mirando no momento de seu tiro, a cabeça de seu inimigo, seu presente passa a ser considerado como válido no servidor, já que ele compensa esta diferenca.</li>
<li>O servidor processa o tiro e transmite para todos os clientes, deixando seu oponente furioso por ter levado um headshot.</li>
</ol>
<p>E é no passo dois que a compensacão de lag ocorre.</p>
<h2 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h2>
<p>Primeira coisa que fizemos foi entender qual o grande problema do desenvolvimento de servidores para jogos, pessoas querendo trapacear, e a partir disso entendemos qual a solução básica, um cliente que só envia comandos pro servidor e um servidor autoritário. Vimos que com um servidor autoritário alguns problemas de defasamento temporal pode ocorrer entre a informação que temos e a informação que o servidor nos obriga a ter. Para reduzir estes problemas aprendemos as técncias de predição e de reconciliação, mas descobrimos problemas de sincronização com outros clientes. Para resolver os problemas de sincronização aprendemos as técncias de dead reckoning e interpolação de entidades, que são ótimas técnicas, mas ainda podem falhar na hora que ações muito sensíveis espacialmente são executadas. Para resolver este problema de ações sensíveis, aprendemos compensação de lag, mas ainda nos falta por a mão na massa. Nos próximos capítulos vamos explorar um jogo simples de tiro e um exemplo de servidor para ele.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-snake-game"><a class="header" href="#multiplayer-snake-game">Multiplayer Snake Game</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sobre-a-bevy"><a class="header" href="#sobre-a-bevy">Sobre a Bevy</a></h1>
<p>Bevy engine é uma das game engines mais promissoras do mercado e um grande esforço coletivo para a comunidade rust_gamedev. Se trata de uma engine orientada a dados, gratuíta e open source, sob as licenças Apache e MIT, ou seja, perfeita para qualquer projeto. Ela possui como objetivos de design:</p>
<ul>
<li>Um conjunto completo de features para jogos 2D e 3D, podendo inclusive ser aplicada para outros objetivos.</li>
<li>Simples e poderosa, mas mantendo o fácil aprendizado.</li>
<li>Orientada a dados utilizando o paradigma ECS (Entity component system, no próximo capítulo).</li>
<li>Modular, use o que quiser, adicione o que quiser, e substitua o que quiser.</li>
<li>Rápida, paralela e em Rust &lt;3.</li>
<li>Compilação rápida</li>
</ul>
<p>A atual versão da Bevy é <a href="https://crates.io/crates/bevy"><img src="https://img.shields.io/crates/v/bevy.svg" alt="Crates.io" /></a> e este livro foi desenvolvido com a versão <code>0.7</code>.</p>
<h2 id="iniciando-o-projeto"><a class="header" href="#iniciando-o-projeto">Iniciando o projeto</a></h2>
<blockquote>
<p>Para iniciar um projeto com a Bevy é necessário possuir Rust e Cargo, caso você não possua basta fazer download em https://rustup.rs/.</p>
</blockquote>
<p>Vamos iniciar nosso projeto com um simples <code>cargo new bevy-snake --bin</code>, que gera um projeto executável em Rust chamado <code>bevy-snake</code>. Este projeto vai possuir um <code>Cargo.toml</code> (onde os metadados do projeto estão localizados), um <code>src/main.rs</code> e um <code>.gitignore</code>:</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<pre><code class="language-sh"># .gitignore 
/target
</code></pre>
<p>Agora adicionamos versão atual da bevy (<code>bevy = &quot;0.7&quot;</code>) a seção <code>[dependencies]</code> do Cargo.toml. Adicionamos também a crate de aleatoriedade <code>rand</code>:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.7&quot;
rand = &quot;0.7&quot;
</code></pre>
<p>Com essas mudanças no <code>Cargo.toml</code> podemos começar a usar o <code>prelude</code> da bevy e criar nosso primeiro app com:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new().run();
}
</code></pre></pre>
<h3 id="instanciando-uma-janela"><a class="header" href="#instanciando-uma-janela">Instanciando uma Janela</a></h3>
<p>Instanciar uma janela com a Bevy é bastante trivial e pode ser feito através do uso de plugins, neste caso o <code>DefaultPlugins</code> contém um conjunto básico de plugins que tornam a bevy operacional:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new().add_plugins(DefaultPlugins).run();
}
</code></pre></pre>
<p>Agora se executarmos <code>cargo run</code> veremos uma janela com fundo cinza. Por padrão, os plugins da Bevy não incluem camera, pois o uso de camera é muito variado em jogos, assim, precisamos criar nosso próprio sistema de cameras. Usaremos uma camera ortográfica 2D com o commando <code>OrthographicCameraBundle::new_2d()</code> em uma função que fará a configuração do sistema de cameras inicial alterando a variável do tipo <code>mut Commands</code>. <code>Commands</code> é um tipo muito comum ao escrever sistemas com a Bevy e é usado para enfileirar comandos com o objetivo de modificar o mundo (que chamaremos de <code>world</code>) e os recursos (que chamaremos de <code>resources</code>). Assim, na função a seguir, <code>setup_camera</code>, receberemos como argumento <code>mut commands: Commands</code> e utilizaremos ele para instanciar (chamado de <code>spawn</code>) uma nova entidade bundle com os componentes de uma câmera 2D ortográfica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
<span class="boring">}
</span></code></pre></pre>
<p>E agora basta adicionar esse função ao nosso <code>App</code> através de um <code>add_startup_system</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugins(DefaultPlugins)
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>A Bevy é pensada de forma que todas suas partes sejam modularizáveis, assim, todas as core features da engine são implementadas como plugins que podem ser substituídos, evoluídos e customizados, além disso, os próprios jogos são encarados como plugins. Assim, se você não precisar de uma UI, basta não registrar o sistema de UI, quer um sistema de UI diferente, registre o seu próprio. Para o caso de servidores, basta não registrar o plugin <code>RenderPlugin</code>.</p>
<p>Caso você não precise de uma experiência tão avançada com a Bevy, é possível utilizar o <code>DefaultPlugins</code> que utilizamos anteriormente, que possui sistemas como Rendering, gerenciamento de assets, sistema de UI, janelas e gerenciamento de entrada de dados.</p>
<h3 id="criando-um-plugin"><a class="header" href="#criando-um-plugin">Criando um Plugin</a></h3>
<p>Para criar um plugin simplesmente precisamos implementar a trait <code>Plugin</code> em um tipo que comporte as informações necessárias. No caso do plugin que vamos implementar é apenas um <code>hello world</code> para plugins, então não precisamos de dados, criando apenas um </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HelloPlugin;

impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // lógica do plugin
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma função que nosso sistema vai executar, neste caso um simples <code>println</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_plugin() {
    println!(&quot;hello plugin!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>E adicionamos essa função como um <code>startup_system</code> no nosso plugin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_startup_system(hello_plugin);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, basta adicionarmos nosso plugin ao <code>App</code> principal e executar <code>cargo run</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugin(HelloPlugin)
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre></pre>
<p>Veremos algo no terminal como:</p>
<pre><code>2022-06-20T05:28:52.725036Z  INFO bevy_render::renderer: AdapterInfo { name: &quot;AMD Radeon Pro 5500M&quot;, vendor: 0, device: 0, device_type: DiscreteGpu, backend: Metal }
hello plugin!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity Component System (ECS)</a></h1>
<p>O sistema de gerenciamento de dados da Bevy é chamado de <em>Entity Component System</em>, ou <strong>ECS</strong>, e sua principal característica é a simplicidade do gerenciamento de dados. Uma boa analogia ao seu funcionamento é com bancos de dados tabulares, na qual os componentes, <em>components</em>, são os tipos de dados, ou colunas, e as entidades, <em>entities</em>, são as linhas, mais especificamente o ID das linhas. Por exemplo, você poderia ter diversas entidades com o componente <code>Health</code> e cada entidade possui um component <code>Health</code> diferente, já que NPCs, players e objetos do mundo podem ter <code>Health</code>s diferentes (<em>health</em> significa vida em inglês). Assim, o conjunto de componentes que uma entidade possui é chamado de arquétipo, <em>Archetype</em>.</p>
<p>Considerando a entidade player possuindo componentes como vida, força, ataque, defesa, inventario, as entidades inimigos com vida, força, ataque, defesa, inteligência, e a entidade planta com apenas vida, fica muito fácil escrever uma lógica de jogo que gerencia esses tipos de entidades, como verificar se uma entidade com vida encontrou outra entidade com vida, simplificando muito a criação de lógicas de jogo. Essa lógica de gerenciamento é chamado sistema, <em>system</em>. Estes sistemas são executados em paralelo pelo <em>smart scheduling algorithm</em> da Bevy e com isso devemos manter nossas entidades o mais horizontal possível, evitando grandes componentes com muitos campos. Isso influência muito a performance do sistema, pois quando mais vertical a entidade mais problemas de acesso aos dados em paralelo teremos.</p>
<blockquote>
<p>Para você que vem da orientação a objectos, no paradigma de ECS é mais comum possuir uma entidade com diversos componentes, como a entidade Player que possui os componentes Vida(u32), Posição(x, y, z), Direção(x, y, z), Escala(x, y, z), Rotação(x, y, z), Defesa(u16), Ataque(u16), Força(u16) em vez de uma classe <code>Player</code> com os campos vida: u32, posição: [x, y, z], direção: [x, y, z], escala: [x, y, z], rotação: [x, y, z], defesa: u16, ataque: u16, força: u16:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefira isso:
// Entidade Player;

#[derive(Component)]
pub struct Vida(u32)

#[derive(Component)]
pub struct Posição(x, y, z)

#[derive(Component)]
pub struct Direção(x, y, z)

#[derive(Component)]
pub struct Escala(x, y, z)

#[derive(Component)]
pub struct Rotação(x, y, z)

#[derive(Component)]
pub struct Defesa(u16)

#[derive(Component)]
pub struct Ataque(u16)

#[derive(Component)]
pub struct Força(u16)

// Em vez disso:
pub struct Player {
    pub vida: u32, 
    pub posição: [x, y, z], 
    pub direção: [x, y, z], 
    pub escala: [x, y, z], 
    pub rotação: [x, y, z], 
    pub defesa: u16, 
    pub ataque: u16, 
    pub força: u16,
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="criando-entidades"><a class="header" href="#criando-entidades">Criando entidades</a></h2>
<p>Entidades são simplesmente IDs inteiros associados a um comando <code>spawn</code> de <code>commands</code>, <code>commands.spawn(...)</code> e para adicionar componentes basta utilizarmos a diretica <code>insert</code> em um <code>spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_entity(mut commands: Commands) {
    commands
        .spawn()
        .insert(Label(&quot;Player&quot;))
        .insert(Vida(10))
        .insert(Posição(0, 2, 0))
        .insert(Direção(0, 2, 0))
        .insert(Escala(0, 2, 0))
        .insert(Rotação(0, 2, 0))
        .insert(Defesa(10))
        .insert(Ataque(10))
        .insert(Força(10));
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, existe o conceito de <em>bundles</em>. <em>Bundles</em> são como <em>templates</em> que tornam a criação de entidades com diversos componentes mais simples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Bundle)]
struct Transform {
    posição: Posição(x, y, z),
    direção: Direção(x, y, z),
    escala: Escala(x, y, z),
    rotação: Rotação(x, y, z),
}

#[derive(Bundle)]
struct Player {
    vida: u32, 
    defesa: u16, 
    ataque: u16, 
    força: u16,

    #[bundle] // Nested bundles
    transform: Transform
}
<span class="boring">}
</span></code></pre></pre>
<p>Como podemos ver em <code>transform: Transform</code>, bundles também podem ser encadeados. Tuplas arbitrárias também são consideradas bundles. Note, que bundles não podem ser consultados com uma <em>query</em>.</p>
<h2 id="recursos-resources"><a class="header" href="#recursos-resources">Recursos (<em>Resources</em>)</a></h2>
<p>Recursos são um tipo de instância que permite armazenar um tipo de dado de forma global, independente de entidades, e qualquer tipo Rust pode ser usado como um recurso independente de implementação de traits. Existem duas formas de inicializar recursos, a primeira é definindo a trait <code>Default</code> para eles, quando eles possuem um tipo de dado simples, já a segunda é implementando a trait <code>FromWorld</code> que permite atuar sobre o recurso utilizando valores de <code>World</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct StartingLevel(usize);

struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS from here.
        // For instance, you can mutate other resources:
        let mut x = world.get_resource_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E para inicializar seus recursos em um App basta usar a função <code>insert_resource</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // Caso implemente uma das traits `Default` ou `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()
        // se for necessário definir o valor inicial
        .insert_resource(StartingLevel(3))
        // ...
        .run();
}
</code></pre></pre>
<p>A decisão de quando usar recursos ou entity/component é baseada na forma e no momento em que este dado vai ser acessado, mas considerando algo como um jogo com uma unica entidade, pode ainda ser útil utilizar o padrão ECS, pois ele permite maior flexibildiade e compartilhamento de dados, que podem ser muito úteis para a evolução do jogo.</p>
<h2 id="sistemas-systems"><a class="header" href="#sistemas-systems">Sistemas (<em>Systems</em>)</a></h2>
<p>Sistemas são funções que a desenvolvedora escreve com o objetivo de ser uma unidade de lógica do jogo atuando sobre as entidades e os componentes. Os sistemas são executados e gerenciados pelas Bevy, mas somente podem ser usados com parâmetros especiais. Os parâmetros especiais são:</p>
<ul>
<li><code>Res/ResMut</code> para acessar recursos.</li>
<li><code>Query</code> para acessar componentes de uma entidade.</li>
<li><code>Commands</code> para criar e destruir entidades, componentes e recursos.</li>
<li><code>EventWriter/EventReader</code> para enviar e receber eventos.</li>
</ul>
<p>Um sistema pode conter no máximo 16 parâmetros, caso seja preciso mais parâmetros pode se agrega-los em tuplas de no máximo 16 parâmetros. Caso estes limites não sejam suficiente, é possível fazer tuplas de tuplas.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    mut c: Option&lt;ResMut&lt;ResourceC&gt;&gt;,
) {
    if let Some(mut c) = c {
        // lógica
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No sistema a cima <code>ResourceA</code> é um recurso imutável e esta compartilhando uma tupla com <code>ResourceB</code>que é um recurso mutável. Já <code>ResourceC</code> é um recurso que pode não existir e por isso está englobado por um tipo <code>Optional&lt;T&gt;</code>.</p>
<p>Existem dois tipos de funções para executar sistemas na Bevy</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // ...
        // sistemas executados apenas quando o App é lançado
        .add_startup_system(init_menu)
        .add_startup_system(debug_start)

        // sistemas executados todos os frames
        .add_system(move_player)
        .add_system(enemies_ai)
        // ...
        .run();
}
</code></pre></pre>
<p>Agora vamos começar a implementar nosso snake game e aprofundar nossos conhecimentos em bevy.</p>
<p><strong>Referência: <a href="https://bevy-cheatbook.github.io/programming.html">unofficial bevy guide</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-cabeça-da-cobra"><a class="header" href="#a-cabeça-da-cobra">A Cabeça da Cobra</a></h1>
<p>Para começar o jogo precisamos do primeiro componente, neste caso a cabeça da cobra, que definirá os próximos possíveis passos, assim como para onde os blocos seguintes se moverão. Este primeiro componente se chamará <code>SnakeHead</code> e será uma struct vazia com a trait <code>Component</code> associada a ela:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component)]
pub struct SnakeHead;
<span class="boring">}
</span></code></pre></pre>
<p>A função de <code>SnakeHead</code> é basicamente ser um marcador para as entidades do tipo snake, que nos permitirá filtrar as estas entidades quando formos fazer queries com os players. Muitos componentes não precisam de estados e podem funcionar apenas como marcadores, um padrão bastante comum no mundo ECS, já que optamos por uma estratégia de <em>has a</em> (possui um) em vez de <em>is a</em> (é um, da orientação a objetos). Outro detalhe importante é a adição de uma cor específica para a cabeça da cobra <code>const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);</code>.</p>
<p>Nosso próximo passo é gerar uma entidade snake, que possui um componente do tipo <code>SnakeHead</code>, e essa entidade pode ser gerada adicionando um sistema inicial com <code>add_startup_system(spawn_snake)</code>, dada a função <code>spawn_snake</code>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
 
#[derive(Component)]
pub struct SnakeHead;
 
fn spawn_snake(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(SnakeHead);
}
</code></pre></pre>
<blockquote>
<p><strong>SpriteBundle</strong></p>
<p><code>SpriteBundle</code> é um tipo de componente que agrega características comuns a uma entidade que utiliza sprites como o próprio sprite (especificidades da imagem), transform (relação de posição, escala e rotação), visibilidade, transform global e o manuseio de imagens.</p>
</blockquote>
<p>Neste caso, não temos nenhuma imagem específica como sprite, mas definimos um transform com uma escala de <code>10 x 10 x 10</code> pixels e uma cor de filtro acinzentada para a região definida pelo transform, as outras propriedades foram definidas como <code>..default()</code>. Ao executarmos <code>cargo run</code> o resultado é algo como:</p>
<p><img src="part-2/../imagens/snake_pixel.png" alt="Entidade snake com SpriteBundle" /></p>
<h2 id="nosso-primeiro-teste"><a class="header" href="#nosso-primeiro-teste">Nosso primeiro teste</a></h2>
<p>No mundo moderno, jogos sem testes estão fadados ao fracasso. Não estou dizendo que todos os jogos possuem uma bateria maravilhosa de testes automatizados, mas desde que escrevi o livro <strong>Lean Game Development</strong> até hoje, o mercado de games AAA mudou muito. Hoje em dia vejo jogos sendo desenvolvidos com TDD e com QA advogando por testes automatizados de gameplay emt todos os sistemas, garantindo uma jogabilidade equilibrada/desejada em qualquer plataforma. Hoje em dia um jogo, middleware, game server ou ferramenta sem nenhum teste esta fadado ao fracasso por conta do número excessivo de bugs e clientes infelizes. Sendo assim, é importante ter uma noção de como testar minimamente seus sistemas com a Bevy. Sendo assim, vamos aprender a escrever o teste mais simples possível, verificar se nosso sistema <code>spawn_snake</code> de fato adiciona um componente <code>SnakeHead</code> à entidade desejada.</p>
<p>Primeiro passo do teste será mover tudo que é relacionado a <code>snake</code> para um módulo chamado <code>snake.rs</code>:</p>
<p><strong><code>main.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
 
mod snake;
 
use snake::spawn_snake;
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<p><strong><code>snake.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
#[derive(Component)]
pub struct SnakeHead;
 
pub fn spawn_snake(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(SnakeHead);
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora em Snake vamos criar um teste dentro de um módulo de testes (<code>#[cfg(test)] mod test {...}</code>) que verifique se um componente <code>SnakeHead</code> está presente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn entity_has_snake_head() {
       // 1 Inicialização do App
       let mut app = App::new();
 
       // 2 Adicionar o `spawn_snake` startup system
       app.add_startup_system(spawn_snake);
 
       // 3 Executar todos os sistemas pelo menos uma vez
       app.update();
 
       // 4 Fazer uma query por entidades que contenham o componente `SnakeHead`
       let mut query = app.world.query_filtered::&lt;Entity, With&lt;SnakeHead&gt;&gt;();
 
       // 5 Verificar se a contagem de componentes da query foi igual a 1
       assert_eq!(query.iter(&amp;app.world).count(), 1);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Descrevendo o teste <code>entity_has_snake_head</code> (verifica se entidade possui componente snake head) temos como primeiro passo (<code>1</code>) criar um <code>App</code> mutável para podermos adicionar sistemas como o <code>spawn_snake</code> (<code>2</code>) e executarmos todos os sistemas pelo menos uma vez com <code>app.update()</code> (<code>3</code>). O próximo passo é realizarmos uma <code>query</code> (<code>4</code>) no sistema de ECS para procurarmos por uma entidade que possua o componente <code>SnakeHead</code> (<code>With&lt;SnakeHead&gt;</code>). Com o resultado desta <code>query</code> verificamos se a quantidade de entidades que possuem o componente <code>SnakeHead</code> é igual a <code>1</code> (<code>5</code>).</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>O principal objetivo de queries é nos permitir acessar componentes de entidades. No código a seguir, temos uma query do tipo <code>Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;</code> que representa todas as entidades que possuam <code>Health</code> e <code>Transform</code>, com a propriedade <code>Health</code> sendo apenas leitura e a propriedade <code>Transform</code> sendo mutável. Além disso, caso o componente <code>Player</code> esteja presente, permite a leitura dele. Depois disso iteramos sobre todos os ítens dessa query, de forma mutável, para podermos alterar a propriedade transform, <code>(health, mut transform, player) in query.iter_mut()</code>. Por último, caso o componente <code>Player</code> esteja presente, sabemos que esta entidade é do tipo player e aplicamos uma lógica extra.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_zero_health(
   mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
   // Obtem todas as entidades do tipo
   for (health, mut transform, player) in query.iter_mut() {
       eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);
 
       // centraliza se `hp` é menor ou igual a `0.0`
       if health.hp &lt;= 0.0 {
           transform.translation = Vec3::ZERO;
       }
 
       if let Some(player) = player {
           // entidade é do tipo `Player`
           // lógica extra
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>para obter o ID de uma entidade com queries basta adicionar <code>Entity</code> a query e a variável <code>entity_id</code> corresponderá ao id:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// adicione `Entity` a `Query` para obter os IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
   for (entity_id, /* ... */) in q.iter() {
       // `entity_id` é o ID da entidade que estamos acessando.
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Caso exista certeza que uma query vai identificar apenas uma entidade, é possível utilizar <code>single</code> e <code>single_mut</code> para acessar seus componentes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
   let (player, mut transform) = q.single_mut();
   // lógica
}
<span class="boring">}
</span></code></pre></pre>
<p>Outro recurso interessante de queries são os <em>Query Filters</em>, um tipo especial de queries que permite reduzir a quantidade de entidade que uma query retorna. <em>Query filters</em> se utilizam dos filtros <code>With</code> e <code>Without</code> para garantir que a entidade tenha (<code>With</code>) ou não tenha (<code>Without</code>) certos componentes. No exemplo a seguir, a query acessa todas as entidades com o componente <code>Health</code> que sejam  <code>Players</code> amigáveis e que opcionalmente possuam <code>PlayerName</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_player_hp(
   query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
   for (health, name) in query.iter() {
       // ...
   }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Utilizando filtros</strong></p>
<ul>
<li>Elementos adicionados em uma Tupla, como <code>(With&lt;Player&gt;, Without&lt;Enemy&gt;)</code>, são considerados <code>AND</code>/<code>E</code> lógicos.</li>
<li>Para utilizar <code>OR</code>/<code>OU</code> lógicos é preciso envolver as tuplas em um filtro do tipo <code>Or&lt;(…)&gt;</code>.</li>
</ul>
</blockquote>
<h2 id="movendo-a-cabeça-da-cobra"><a class="header" href="#movendo-a-cabeça-da-cobra">Movendo a cabeça da cobra</a></h2>
<p>Não existe o Snake game sem movimento, então o próximo passo é controlarmos os movimentos da cabeça da cobra com as teclas <code>WASD</code> ou direcionais. Para isso, podemos começar com a movimentação para cima utilizando o teste:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_has_moved_up() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   // Adicionando sistemas
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Adicionando inputs de `KeyCode`s
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::W);
   app.insert_resource(input);
 
   // Executando sistemas pelo menos uma vez
   app.update();
 
   // Query para obter entidades com `SnakeHead` e `Transform`
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
 
   // Verificando se o valor de Y no `Transform` mudou
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &lt; transform.translation.y);
       assert_eq!(default_transform.translation.x, transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste teste adicionamos um <code>Transform</code> com valores padrão de <code>translation</code> para comparar quando o transform da query mudar, adicionamos um novo sistema de movimento <code>add_system(snake_movement)</code> e criamos um recurso que gerencia inputs de teclado <code>Input::&lt;KeyCode&gt;::default()</code>, na qual setamos seu evento <code>press</code> como <code>KeyCode::W</code>. Para resolver este teste precisamos criar o sistema <code>snake_movement</code>, que é bastante trivial neste caso, apenas um sistema que busca por um query contendo <code>&amp;SnakeHead</code> e <code>&amp;Transform</code>, depois modifica o valor de Y de forma que sempre aumente:</p>
<pre><pre class="playground"><code class="language-rust">// snake.rs
pub fn snake_movement(mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;) {
   for (_head, mut transform) in head_positions.iter_mut() {
       transform.translation.y += 1.;
   }
}
 
// main.rs
// ...
mod snake;
use snake::{spawn_snake, snake_movement};
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .add_system(snake_movement)
       .run();
}
// ...
</code></pre></pre>
<h3 id="controlando-a-direção-de-movimento"><a class="header" href="#controlando-a-direção-de-movimento">Controlando a direção de movimento</a></h3>
<p>Nosso movimento atual está longe de ser realista ou funcional, para isso precisamos que a cobra se movimente com base nas teclas <code>wasd</code> e podemos começar com um teste que move a cobra 1 unidade para cima, verificando que apenas o <code>y</code> mudou em relacao ao original, depois uma unidade para direita, verificando que apenas o <code>x</code> mudou em relação ao anterior. Por último, um novo teste movendo para baixo e para esquerda, verificando se as posições são inferiores às originais em <code>x</code> e <code>y</code>. Assim, o primeiro teste fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_moves_up_and_right() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   // Adiciona systemas
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Testa movimento para cima
   let mut up_transform = Transform {..default()};
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::W);
   app.insert_resource(input);
   app.update();
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &lt; transform.translation.y);
       assert_eq!(default_transform.translation.x, transform.translation.x);
       up_transform = transform.to_owned();
   });
 
   // Testa movimento para direita
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::D);
   app.insert_resource(input);
   app.update();
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert_eq!(up_transform.translation.y , transform.translation.y);
       assert!(up_transform.translation.x &lt; transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao executarmos este teste percebemos que a linha <code>assert_eq!(up_transform.translation.y , transform.translation.y);</code> falha pois nosso <code>transform.translation.y</code> está maior que o anterior, que faz sentido, já que nosso sistema de movimento está apenas aumentando o <code>y</code> a cada update. Para resolvermos isso, podemos adicionar os comandos para se mover com <code>w</code> e com <code>d</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;
) {
   for (_head, mut transform) in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Teste passando, então podemos fazer o segundo teste, movimento para baixo e para esquerda. O teste é basicamente igual ao anterior, mas reduzimos algumas linhas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_moves_down_and_left() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Movimenta para baixo
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::S);
   app.insert_resource(input);
   app.update();
 
 
   // Movimenta para esquerda
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::A);
   app.insert_resource(input);
   app.update();
 
   // Assert
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &gt; transform.translation.y);
       assert!(default_transform.translation.x &gt; transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Como esperado, o teste falha e podemos implementar as condições que faltam de pressionar o teclado, <code>s</code> e <code>a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;
) {
   for (_head, mut transform) in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Tudo passa e podemos ir para o próximo passo, explicar e melhorar este código. O argumento <code>keyboard_input</code> é um recurso que contém os eventos relacionados a tecla que foi pressionada no <code>input</code>, ou seja, <code>Res&lt;Input&lt;KeyCode&gt;&gt;,</code>. Nossa query faz sentido e está funcional, porém, como não estamos utilizando o componente <code>SnakeHead</code>, representado por <code>_head</code>, podemos mudar nossa query para <code>Query&lt;&amp;mut Transform, With&lt;SnakeHead&gt;&gt;</code>, que altera nosso código para utilizar apenas o transform como variável:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;&amp;mut Transform, With&lt;SnakeHead&gt;&gt;
) {
   for mut transform in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Como mencionamos antes sobre o <code>With</code>, ele nos permite buscar todas as entidades que possuam o componente <code>SnakeHead</code>, mas explícita para a Bevy que não nos importamos com o conteúdo de <code>SnakeHead</code>, apenas com o <code>Transform</code>. Isso é importante pois quanto menos componentes o sistema precisar acessar, mais a bevy conseguirá paralelizar as coisas.</p>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>Uma coisa bastante importante enquanto desenvolvemos é termos um sistema de integração contínua executando. No caso do Rust no Github eu recomendo utilizar o <em>Github Actions</em> e minha configuração base para projetos Rust é:</p>
<pre><code class="language-yaml">name: Rust
 
on:
 push:
   branches: [ &quot;main&quot; ]
 pull_request:
   branches: [ &quot;*&quot; ]
 
env:
 CARGO_TERM_COLOR: always
 
jobs:
 build:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v3
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: Build
     run: cargo build --release --verbose
    
 test:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: tests
     run: cargo test -- --nocapture
  fmt:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: FMT
     run: cargo fmt -- --check
 
 clippy:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: install-clippy
     run: rustup component add clippy
   - name: clippy
     run: cargo clippy -- -W clippy::pedantic --deny &quot;warnings&quot;
 
</code></pre>
<p>Ao executarmos o CI, percebemos que a formatação não estava correta, que pode ser corrigida com <code>cargo fmt</code>, e há algumas sugestões de linting em relação a nomenclatura das funções e structs no módulo e declaração de argumentos. A questão de nomenclatura solicita que funções e structs não comecem com o nome do módulo. A declaração de argumentos solicita que o tipo de <code>keyboard_input</code> seja passado como referência <code>keyboard_input: &amp;Res&lt;Input&lt;KeyCode&gt;&gt;</code>, porém isso quebra a injeção de recursos da bevy, necessitando assim que o lint seja descartado com <code>#[allow(clippy::needless_pass_by_value)]</code>. Meu único problema com a questão de nomenclatura é perder o contexto de que os sistemas e as structs quando utilizamos importações absolutas em vez de qualificadas. A solução é utilizar importações qualificadas. O código ficou assim:</p>
<pre><pre class="playground"><code class="language-rust">// Snake.rs
use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
#[derive(Component)]
pub struct Head;
 
pub fn spawn_system(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(Head);
}
 
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;&amp;mut Transform, With&lt;Head&gt;&gt;,
) {
   for mut transform in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
 
#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn entity_has_snake_head() {
       // Setup app
       let mut app = App::new();
 
       // Add startup system
       app.add_startup_system(spawn_system);
 
       // Run systems
       app.update();
 
       let mut query = app.world.query_filtered::&lt;Entity, With&lt;Head&gt;&gt;();
       assert_eq!(query.iter(&amp;app.world).count(), 1);
   }
 
   #[test]
   fn snake_head_has_moved_up() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Add input resource
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::W);
       app.insert_resource(input);
 
       // Run systems
       app.update();
 
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &lt; transform.translation.y);
           assert_eq!(default_transform.translation.x, transform.translation.x);
       })
   }
 
   #[test]
   fn snake_head_moves_up_and_right() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Move Up
       let mut up_transform = Transform { ..default() };
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::W);
       app.insert_resource(input);
       app.update();
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &lt; transform.translation.y);
           assert_eq!(default_transform.translation.x, transform.translation.x);
           up_transform = transform.to_owned();
       });
 
       // Move Right
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::D);
       app.insert_resource(input);
       app.update();
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert_eq!(up_transform.translation.y, transform.translation.y);
           assert!(up_transform.translation.x &lt; transform.translation.x);
       })
   }
 
   #[test]
   fn snake_head_moves_down_and_left() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Move down
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::S);
       app.insert_resource(input);
       app.update();
 
       // Move Left
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::A);
       app.insert_resource(input);
       app.update();
 
       // Assert
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &gt; transform.translation.y);
           assert!(default_transform.translation.x &gt; transform.translation.x);
       })
   }
}
 
// Main.rs
use bevy::prelude::*;
 
mod snake;
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(snake::spawn_system)
       .add_plugins(DefaultPlugins)
       .add_system(snake::movement_system)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
 
</code></pre></pre>
<p>A seguir vamos criar o conceito de Grid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grade-de-movimento"><a class="header" href="#grade-de-movimento">Grade de Movimento</a></h1>
<p>Nosso sistema de movimentação tem utilizado coordenadas da janela para fazer a movimentação, sendo o ponto <code>(0,0)</code> o centro da janela e cada unidade corresponde a um pixel, porém o snake game utiliza um sistema de grade. Assim, precisamos definir uma grade básica com tamanho da grade de <code>10 x 10</code> e células da grade com mais de 1 pixel para evitar janelas de 10 px por 10 px. Além disso, definir uma grade a aprtir do centro é bastante complexo, por isso vamos utilizar nosso próprio sistema de coordenadas e criar um sistema que faça a conversão. Nosso primeiro passo é adicionar constantes referentes ao tamnho da arena. É importante que estas constantes sejam definidas fora, pois quando iniciarmos o modo multiplayer <code>10 x 10</code> será muito pequena. </p>
<pre><code class="language-rs">// main.rs
mod snake;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;

fn main() {
    // ...
}
</code></pre>
<p>As constantes <code>GRID_WIDTH</code> e <code>GRID_HEIGHT</code> referemm a largura da arena e a altura da arena, respectivamente. Agora criamos um novo módulo <code>components</code> que é responsável por gerenciar componentes básicos e transversair do jogo, como posição (<code>Position</code>) e tamanho de célula (<code>Size</code>):</p>
<pre><code class="language-rs">// main.rs
mod snake;
pub mod components;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;
// ...

// components.rs
use bevy::prelude::Component;

#[derive(Component, Clone, Debug, PartialEq, Eq)]
pub struct Position {
    pub x: i32,
    pub y: i32,
}

#[derive(Component, Debug, PartialEq)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

impl Size {
    pub fn square(x: f32) -&gt; Self {
        Self {
            width: x,
            height: x,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn sized_square_is_created_calling_square_fn() {
        let expected = Size {width: 3.14, height: 3.14};
        let actual = Size::square(3.14);

        assert_eq!(actual, expected);
    }
}
</code></pre>
<p>No arquivo de components precisamos apenas importar a trait <code>Component</code> e definir as structs <code>Position</code> com <code>x, y</code> e <code>Size</code> com <code>width,height</code>. O único teste presente é o <code>sized_square_is_created_calling_square_fn</code> pois ele testa se um quadrado de lado <code>f</code> é criado quando chamamos a função <code>Size::square</code>. Ou seja, <code>Size::square</code> é um método para ajudar a gerar células, ou qualquer outra coisa que tenha tamanho, de altura e largura iguais. Outra coisa importante de salientar são as várias traits derivadas em <code>Position</code>, no futuro elas devem nos ajudar a utilizar <code>Position</code>. Próximo passo é incorporar estes componentes na cobra que temos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::components::{Position, Size};

const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);

#[derive(Component)]
pub struct Head;

pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Head) // Remover ;
        .insert(Position { x: 5, y: 5 }) // &lt;-
        .insert(Size::square(0.8));  // &lt;-
}
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos os testes agora, vamos ver que não há nenhuma alteração significativa, pois todos os testes seguem passando. Agora precisamos de uma função auxiliar para gerenciar a escala de cáda célula da cobra e da grade, assim como uma função que faça a correspondência entre posição na grade e posição na janela. Vamos começar com a mais fácil, escala, que chamaremos de <code>size_scaling</code>. Antes, criamos um módulo chamado <code>grid</code> e movemos <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code> para este módulo:</p>
<pre><code class="language-rs">// grid.rs
use bevy::prelude::*;
use crate::components::Size;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;

pub fn size_scaling(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Size, &amp;mut Transform)&gt;) {
    let window = windows.get_primary().unwrap();
    for (sprite_size, mut transform) in q.iter_mut() {
        scale_sprite(transform.as_mut(), sprite_size, window);
    }
}

fn scale_sprite(transform: &amp;mut Transform, sprite_size: &amp;Size, window: &amp;Window) {
    transform.scale = Vec3::new(
        sprite_size.width / GRID_WIDTH as f32 * window.width() as f32,
        sprite_size.height / GRID_HEIGHT as f32 * window.height() as f32,
        1.0,
    );
}

#[cfg(test)]
mod test {
    use bevy::window::WindowId;
    use raw_window_handle::{RawWindowHandle, WebHandle};
    use crate::{components::Size};

    use super::*;

    #[test]
    fn transform_has_correct_scale_for_window() {
        // Setup
        let expected_transform = Transform { scale: Vec3::new(20., 20., 1.,),..default() };
        let mut default_transform = Transform { scale: Vec3::new(2., 3., 4.,),..default() };
        let sprite_size = Size::square(1.);

        // Create window
        let mut descriptor = WindowDescriptor::default();
        descriptor.height = 200.;
        descriptor.width = 200.;
        let raw_window_handle = RawWindowHandle::Web(WebHandle::empty());
        let window = Window::new(WindowId::new(), &amp;descriptor, 200, 200, 1., None, raw_window_handle);

        // Apply scale
        scale_sprite(&amp;mut default_transform, &amp;sprite_size, &amp;window);

        assert_eq!(default_transform, expected_transform);
    }
}
</code></pre>
<p>Infelizmente, o recurso <code>Windows</code> é bastante complicado de testar pois causa muitos problemas com o sistema de sincronização e agendamento do ECS da Bevy, por isto, neste caso não vamos testar o sistema em si, mas sim a lógica que o sistema chama, a função <code>scale_sprite</code>. A lógica de <code>size_scaling</code> é a seguinte: Se algo possui uma <code>Size.width</code> e uma <code>Size.height</code>, neste caso <code>sprite_size.width</code> e <code>sprite_size.height</code>, igual a 1.0, em uma grade de tamanho 40, em uma janela de tamanho 400 px, então a largura deveria ser 10, pois <code>1.0 / 40. * 400. = 10</code>. Ou seja, para este teste, os valores iniciais de <code>default_transform</code> não importam, apenas os valores préconfigurados de <code>Size</code>, <code>Window</code>, <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code>.</p>
<p>Note que no teste estamos utilizando a biblioteca <code>raw_window_handle</code>, na versão <code>0.4.3</code>, para gerar as informações de window e que criamos uma janela de <code>200 x 200</code>.</p>
<p>A próxima função é a responsável por transformar a posição em uma coordenada de janela, então, de novo, não poderemos testar o sistema em si, apenas os blocos lógicos que serão divididos em 2:</p>
<ol>
<li>Função <code>convert</code> responsável por calcular o fator de conversão de posição para window.</li>
<li>Aplicar a conversão ao <code>Transform.translation</code>, posição na janela.</li>
</ol>
<p>Vamos criar 2 testes para <code>convert</code>:</p>
<pre><code class="language-rs">#[test]
fn convert_position_x_for_grid_width() {
    let x = convert(4., 400., GRID_WIDTH as f32);

    assert_eq!(x, -20.)
}

#[test]
fn convert_position_y_for_grid_height() {
    let y = convert(5., 400., GRID_HEIGHT as f32);

    assert_eq!(y, 20.)
}
</code></pre>
<p>Estes testes tem como principal objetivo, impedir mudanças que quebrem o código, assim, sua implementaçnao é apenas:</p>
<pre><code class="language-rs">fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}
</code></pre>
<p>Calculamos o <code>tilesize</code> como o tamanho da janela dividido pela quantidade de elementos da grade. Depois a posição passa a ser em relação à grade, algo como <code>5/ 10 = 0.5</code> multilicado pelo tamanho da window, porém como a bevy o ponto <code>(0,0)</code> é no centro da janela, precisamos deslocal meia janela (<code>- (bound_window / 2.)</code>) e centralizar o tile com <code>+ (tile_size / 2.)</code>. </p>
<p>Próximo passo é criar a função que executa a translação do valor do componente <code>Position</code> para o correspondente da posiçnao na janela no componente <code>Transform</code>, como é uma função muito simples, vamos adicionar apenas um teste básico:</p>
<pre><code class="language-rs">fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}

// mod test:
#[test]
fn translate_position_to_window() {
    let position = Position {x: 2, y: 8};
    let mut default_transform= Transform::default();
    let expected = Transform { translation: Vec3::new(-100., 140., 0.,),..default() };

    // Create window
    let mut descriptor = WindowDescriptor::default();
    descriptor.height = 400.;
    descriptor.width = 400.;
    let raw_window_handle = RawWindowHandle::Web(WebHandle::empty());
    let window = Window::new(WindowId::new(), &amp;descriptor, 400, 400, 1., None, raw_window_handle);
    
    // Apply translation
    translate_position(&amp;mut default_transform, &amp;position, &amp;window);

    assert_eq!(default_transform, expected);
}
</code></pre>
<p>Agora agregando tudo na função <code>position_translation</code> temos:</p>
<pre><code class="language-rs">pub fn position_translation(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Position, &amp;mut Transform)&gt;) {
    let window = windows.get_primary().unwrap();
    for (pos, mut transform) in q.iter_mut() {
        translate_position(transform.as_mut(), pos, window);
    }
}

fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}

fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}
</code></pre>
<p>Próximo passo é adicionar os sistemas que criamos à função main utilizando o <code>App::Builder</code>. Este sistema é um caso especial, pois deve ser executado após o método update já que qualquer componente que seja adicionado no update corrente será visivel somente no próximo estágio (por exemplo <code>PostUpdate</code> e <code>Draw</code>) e as funções  <code>position_translation</code> e <code>size_scaling</code> somente conseguiram ver nodos novos da cobra ou comidas nova no estágio seguinte. Esta configuração especial é representada utilizando o <code>CoreStage::PostUpdate</code>  na função de adicionar sistemas  <code>add_system_set_to_stage</code>:</p>
<pre><code class="language-rs">// main
pub mod grid;

fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p><img src="part-2/../imagens/simpleblock.png" alt="Resultado do código até agora" /></p>
<h2 id="corrigindo-a-movimentação-na-grade"><a class="header" href="#corrigindo-a-movimentação-na-grade">Corrigindo a Movimentação na Grade</a></h2>
<p>Até agora nosso sistema de movimento, <code>snake::movement_system</code>, era baseado em movimentar o componente <code>Transform</code> pela janela, porém com a implementação de grade precisamos atualizar o sistema para utilizar o componente <code>Position</code>. Primeiro passo será atualizar os testes para utilizar <code>Position</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
#[cfg(test)]
mod test {
    // ...

    #[test]
    fn snake_head_has_moved_up() {
        // Setup
        let mut app = App::new();
        let default_position = Position{x: 3, y: 4}; // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Add input resource
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);

        // Run systems
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;default_position, position);  // &lt;--
        })
    }

    #[test]
    fn snake_head_moves_up_and_right() {
        // Setup
        let mut app = App::new();
        let up_position = Position{x: 3, y: 4};  // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Move Up
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(position, &amp;up_position);  // &lt;--
        });

        let up_right_position = Position{x: 4, y: 4};  // &lt;--

        // Move Right
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::D);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;up_right_position, position);  // &lt;--
        })
    }

    #[test]
    fn snake_head_moves_down_and_left() {
        // Setup
        let mut app = App::new();
        let down_left_position = Position{x: 2, y: 2};  // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Move down
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::S);
        app.insert_resource(input);
        app.update();
        
        // Move Left
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::A);
        app.insert_resource(input);
        app.update();

        // Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;down_left_position, position);  // &lt;--
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Como agora estamos lidando com valores inteiros, nossos testes podem verificar se a posição mudou com <code>assert_eq!</code> em vez de utilizar expressões lógicas com <code>assert!</code>. Além disso, Position inicial com o valor <code>Position { x: 3, y: 3 }</code>, por isso os valores são maiores que <code>0</code>. Ao executarmos os testes veremos que todas as positions estão iguais a ``Position { x: 3, y: 3 }`, corrigimos isso modificando a função de input:</p>
<pre><code class="language-rs">// snake.rs
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut head_positions: Query&lt;&amp;mut Position, With&lt;Head&gt;&gt;,
) {
    for mut position in head_positions.iter_mut() {
        if keyboard_input.pressed(KeyCode::D) {
            position.x += 1;
        }
        if keyboard_input.pressed(KeyCode::W) {
            position.y += 1;
        }
        if keyboard_input.pressed(KeyCode::A) {
            position.x -= 1;
        }
        if keyboard_input.pressed(KeyCode::S) {
            position.y -= 1;
        }
    }
}
</code></pre>
<p>Agora sim, movimentamos o bloco célula a célula, infelizmente muito sensivel.</p>
<h2 id="configurando-a-janela"><a class="header" href="#configurando-a-janela">Configurando a Janela</a></h2>
<p>Próximo passo é fazermos com que a janela seja mais coerente com o snake game, já que por padrão a janela do snake game é quadrada enquanto a janela padrão da bevy é retangular. Para fazer isso, precisamos adicionar um recurso chamado <code>WindowDescriptor</code> que nos permite configurar o tamanha da tela e o título da janela:</p>
<pre><code class="language-rs">// mains.rs

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()         
        }) // &lt;--
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p>Outra mudança que pode ser interessante fazer é mudar o fundo da tela para ficar um pouco mais escuro, podemos fazer isso adicionando o recurso <code>.insert_resource(ClearColor(Color::rgb(0.04, 0.04, 0.04)))</code> depois do <code>WindowDescriptor</code>. Próximo passo é fazermos a comida aparecer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerador-de-comidas"><a class="header" href="#gerador-de-comidas">Gerador de Comidas</a></h1>
<p>Nosso próximo passo é começarmos um sistema que gere comidas de forma aleatória pela grade. O primeiro passo é definir qual sera a cor da comida. Como pretendemos fazer um jogo multiplayer, não faz sentido termos comidas coloridas, já que estas serão dos jogadores, sendo assim podemos criar um módulo chamado <code>food</code> e adicionar a constante <code>const FOOD_COLOR: Color = Color::rgb(1.0, 1.0, 1.0)</code>. Próximo passo é criamos um componente chamado <code>Food</code> para representar a comida:</p>
<pre><code class="language-rs">// food.rs
#[derive(Component)]
pub struct Food;
</code></pre>
<p>Próximo passo é criarmos um sistema que gera uma comida em um local aleatório da grade. Como este sistema utiliza aleatoriedade, podemos utilizar uma biblioteca de <code>property testing</code> semelhante a <em>proptest</em> do python, a <em>propcheck</em> do Elixir e a <em>quickcheck</em> do Haskell, chamada <code>proptest</code> para gerar centenas de cenários de teste. Para isso, adicionamos <code>proptest = &quot;1.0.0&quot;</code> como uma <code>dev-dependencies</code> no Cargo.toml e para utilizarmos basta utilizar a macro <code>proptest!</code> e determinar os valores a serem executados (ou quantidade de cenários) como argumento da função de teste como em <code>_execution in 0u32..1000</code>:</p>
<pre><code class="language-rs">#[cfg(test)]
mod test {
    use crate::components::Position;

    use super::*;
    use proptest::prelude::*;

    proptest!{
        #[test]
        fn spawns_food_inplace(_execution in 0u32..1000) {
            // Setup app
            let mut app = App::new();

            // Add startup system
            app.add_startup_system(spawn_system);

            // Run systems
            app.update();

            let mut query = app.world.query_filtered::&lt;&amp;Position, With&lt;Food&gt;&gt;();
            assert_eq!(query.iter(&amp;app.world).count(), 1);
            query.iter(&amp;app.world).for_each(|position| {
                let x = position.x;
                let y = position.y;

                assert!(x &gt;= 0 &amp;&amp; x as i32 &lt;= (GRID_WIDTH -1) as i32);
                assert!(y &gt;= 0 &amp;&amp; y as i32 &lt;= (GRID_HEIGHT -1) as i32);
            })
        }
    }
}
</code></pre>
<p>A vantagem de um proptest é que ele permite executar diversos cenários e podemos definir regras de limite para falha, executando centenas de cenários em poucos segundos. Para este teste passar, precisamos implementar a função <code>spawn_system</code> para o módulo <code>food</code>:</p>
<pre><code class="language-rs">// food.rs
pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: FOOD_COLOR,
                ..default()
            },
            ..default()
        })
        .insert(Food)
        .insert(Position {
            x: (random::&lt;u16&gt;() % GRID_WIDTH) as i16,
            y: (random::&lt;u16&gt;() % GRID_HEIGHT) as i16,
        })
        .insert(Size::square(0.8));
}
</code></pre>
<p>O próximo passo é adicionar o sistema a <code>App</code> na função <code>main</code>, porém este sistema tem uma pegadinha. Como não queremos que o sistema gere uma nova comdia para cada frame, precisamos definir um tempo de intervalo para as comidas serem geradas. Como este cenário de executar uma função somente a cada x segundos é muito comum no desenvolvimento de jogos a Bevy nos disponibiliza a struct <code>FixedTimestep</code> que nos permite definir um passo (<code>step</code>) em segundos, que será usada com a função <code>with_run_criteria</code>:</p>
<pre><code class="language-rs">// main.rs
pub mod food;

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()
        }) // &lt;--
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(FixedTimestep::step(1.0)) // &lt;-- Pegadinha
                .with_system(food::spawn_system), // &lt;-- Sistema
        ) // &lt;--
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p>Próximo passo será melhorar o movimento da cabeça da cobra, tornando ele mais lento e cadenciado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="melhorando-a-cadência-do-movimento"><a class="header" href="#melhorando-a-cadência-do-movimento">Melhorando a Cadência do Movimento</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
