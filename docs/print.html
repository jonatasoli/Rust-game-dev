<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento de Jogos online com Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li class="chapter-item expanded "><a href="part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Capa conceitos básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predição e Reconciliação</a></li><li class="chapter-item expanded "><a href="part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpolação de Entidades</a></li><li class="chapter-item expanded "><a href="part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensacão de Lag</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="desenvolvimento-de-jogos-online-com-rust"><a class="header" href="#desenvolvimento-de-jogos-online-com-rust">Desenvolvimento de Jogos Online com Rust</a></h1>
<p>Por Julia Naomi Boeira.</p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<h1 id="conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais"><a class="header" href="#conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais">Conceitos importantes para o desenvolvimento de serviços de jogos digitais</a></h1>
<ol>
<li>O problema e sua arquitetura básica.</li>
<li>Predição e reconciliação.</li>
<li>Interpolação de entidades.</li>
<li>Compensação de lag.</li>
</ol>
<h1 id="o-problema-e-sua-arquitetura-básica"><a class="header" href="#o-problema-e-sua-arquitetura-básica">O problema e sua arquitetura básica.</a></h1>
<p>Neste capítulo vamos entender quais os problemas que serviços para games enfrentam e quais são algumas das formas de resolvê-los para obtermos um conjunto de serviços que tornam o desenvolvimento de jogos multiplayer uma realidade. </p>
<blockquote>
<p><em>Multiplayer</em></p>
<p>Jogos multiplayer são jogos com mais de uma pessoa jogando simultaneamente se conectando através de um servidor.</p>
</blockquote>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Desenvolver um jogo é bastante complicado, agora desenvolver um jogo para mais de uma pessoa jogando é ainda mais complicado. Felizmente, podemos resumir os problemas que servidores de jogos possuem em duas categorias:</p>
<ol>
<li>Humanos maliciosos.</li>
<li>Física realística.</li>
</ol>
<h3 id="humanos-maliciosos"><a class="header" href="#humanos-maliciosos">Humanos Maliciosos</a></h3>
<p>Tudo começa com o desejo das pessoas de trapacear em um jogo.</p>
<p>Podemos dizer que para jogos single-player, ou de somente uma pessoa jogando, trapacear afeta a experiência, mas é uma escolha da pessoa burlar a experiência do jogo, a final a trapaça não afeta ninguém além da pessoa, porém para jogos multiplayer o cenário é diferente. Em um jogo multiplayer, uma pessoa burlando as regras do jogo pode conseguir algumas vantagens que além de afetar sua experiência, tornam a experiência das outras pessoas muito pior. Alguns exemplos que já vi na minha vida:</p>
<ul>
<li>Vida muito maior que 100%, ou seja, a pessoa possuia 1000% de vida em uma partida, tornando ela quase imortal, já que colecionava muito mais recursos.</li>
<li>Tiros duplos ou triplos, ou seja, para cada vez que a pessoa realizava um tiro, duas ou três balas eram enviadas ao mesmo tempo, reduzindo muito as chances do alvo de sobreviver.</li>
<li>Atravessar paredes, não sei bem como este mod funcionava, mas acredito que projetava a pessoa para além do objeto de colisão.</li>
<li>Paredes invisíveis, ou seja, a pessoa havia removido a renderização de objetos inanimados, o que a permitia visualizar todos os alvos antes de ser percebida.</li>
<li>Velocidade 2, ou seja, para cada passo da pessoa, o jogo a movia 2 vezes mais rápido.</li>
</ul>
<p>Tendo estes eventos em mente, podemos concluir que existe uma única solução realmente confiável para um servidor NÃO CONFIAR NO USUÁRIO.</p>
<h2 id="como-não-confiar-no-usuário"><a class="header" href="#como-não-confiar-no-usuário">Como não confiar no usuário?</a></h2>
<p>A resposta para está pergunta é na verdade bastante simples, o cliente, ou seja a pessoa jogando, deve fornecer o mínimo de informações em relação ao seu posicionamento, balas disparadas, direção, etc. Enquanto isso, o servidor deve ser autoritário, recendendo estes comandos básicos e informado para o cliente o que está acontecendo. Em outras palavras, o cliente envia comandos e botões pressionados para o servidor, o servidor executa o próximo passo do jogo e devolve ao cliente as novas informações. Isso não vai impedir que o servidor seja explorado de vulnerabilidades, mas reduzirá drasticamente a capacidade de uma pessoa jogando de trapacear. Assim, para o caso da pessoa que está dando tiros múltiplos, ela pode até ver 3 tiros saindo de sua arma, mas o servidor reconhecerá somente 1 e propagará ao resto do jogo somente 1. </p>
<p>Resumindo, o gerenciamento do estado do jogo é realizado apenas pelo servidor. Clientes enviam apenas suas interações com o controle, teclado e mouse para o servidor. O servidor atualiza o estado do jogo e envia esta informação de volta aos clientes que apenas renderizam ela em sua tela.</p>
<h2 id="o-problema-com-a-física"><a class="header" href="#o-problema-com-a-física">O problema com a física</a></h2>
<p>Parece uma solução perfeita né? Infelizmente ela funciona bem somente quando o jogo é baseado em turnos, como jogos de carta e alguns RPGs, ou a rede é em LAN, já que neste cenário a comunicação com o servidor é considerada instantânea. Para jogos como Call of Duty e Rainbow Six está estratégia vai contar com um enorme delay já que precisam se conectar com servidores distantes.</p>
<p>Assim, vamos supor o meu cenário. Mesmo que minha conexão à internet seja sensacional (mentira, isso não existe), estou em Porto Alegre e o servidor mais próximo está em São Paulo para o jogo X. Porto Alegre e São Paulo estão distantes entre si mais de 1100 km. Na física a velocidade da luz é a maior velocidade atingível por um corpo (photons no caso), ou seja 300.000 km/s no vácuo, assim a luz levaria 3,7 milisegundos para percorrer os 1100 km (1100/300000 = 0,0036667 segundos). Essa é a velocidade da luz no vácuo, parece bem otimista né? Mas neste caso estamos falando de bytes trafegando pela internet, que na prática são elétrons e pulsos de luz trafegando por um cabo, e provavelmente não em linha reta, o que deve aumentar esse valor de 3,7 por alguns microsegundos. Existe mais um fator importante em como a internet funciona, os dados trafegados pela internet são na verdade uma séries de pacotes, ou <em>hops</em>, que trafegam de um roteador ao outro, certamente abaixo da velocidade da luz. Além disso, roteadores possuem um atraso extra, já que todos os pacotes devem ser abertos, copiados e inspecionados para então serem reroteados a seus destinos finais.</p>
<p>Vamos então dizer que o atraso dos meus pacotes até São Paulo leva 25 ms, o que seria um tempo excepcional (neste momento um ping da minha máquina ao google.com está levando entre 25 e 30 ms), mas tempos de 50 ms e até 200 ms não seria impressionantes para certas situações. Agora vamos dizer que nossa jogadora apertou para atirar no momento x, isso quer dizer que nosso servidor receberá a ação de atirar 25 ms depois. Digamos que nosso servidor processe o evento em um tempo substancialmente menor que 1 milisegundo, algo como 500 us, isso quer dizer que quando o servidor responder, a jogadora receberá essa atualização 50 ms depois de ter clicado para atirar. Humanos em média enxergam 25 frames por segundo, o que indica que o delay já é maior que nossa capacidade de observação por 10 ms. Esses 10 ms de delay na nossa percepção já são suficiente para termos uma experiência ruim de jogabilidade, ou seja, o famoso <em>lag</em>, ou atraso. A imagem a seguir demonstra este efeito:</p>
<p><img src="part-1/../imagens/ping_time.jpg" alt="Diagrama de atraso na conexão cliente servidor" /></p>
<h1 id="predição-e-reconciliação"><a class="header" href="#predição-e-reconciliação">Predição e Reconciliação</a></h1>
<p>No capítulo anterior falamos sobre o lag, ou atraso entre ação no cliente e a atualização enviada pelo servidor nos baseando no modelo de cliente servidor na qual o cliente não responde seu estado, mas sim a ação desejada, para que o servidor atualize seu estado. Um jogo que pode levar algumas frações de segundo para atualizar o estado pode ser considerado de jogabilidade ruim ou injogável devido ao lag de renderização. Assim, neste capítulo vamos explorar uma solução para minimizar este problema.</p>
<h2 id="predição-pelo-lado-do-cliente"><a class="header" href="#predição-pelo-lado-do-cliente">Predição pelo lado do cliente</a></h2>
<p>Como a maior parte dos jogos é deterministico, ou seja, não há aleatoriedade no resultado, podemos prever qual vai ser o próximo passo do jogo antes do servidor responder. Para maior parte das pessoas jogando esta experiência será &quot;idêntica&quot; ao jogo sem servidor, mas para as pessoas trapaceando a experiência não será realistica, desfavorecendo o jogo com trapaças. Assim, podemos assumir que nosso servidor receberá ações válidas para 99% dos casos, nos permitindo prever o próximo instante.</p>
<p>No cenário que descrevemos anteriormente nossa ação com o servidor levava 50 ms para atualizar o estado do jogo, para só então uma animação ser ativada (digamos que ela leve mais 50 ms) como a imagem a seguir nos mostra:</p>
<p><img src="part-1/../imagens/animation_time.jpg" alt="Diagrama de atraso na conexão cliente servidor com tempo de animação" /></p>
<p>Nessa imagem podemos ver que o atraso do servidor (50 ms) mais o tempo de animação (50 ms) fará com que percebemos o tiro apenas 100 ms depois dele ter sido realizado, ou seja, no terceiro frame que nosso olho detecta, certamente uma experiência desagradável. </p>
<p>Como o jogo nosso jogo é deterministico, podemos presumir que a ação será executada com sucesso no servidor, aplicar nossas regras locais de validação e iniciar a animação do tiro no momento em que pressionamos o botão para realizar a ação. Para a grande maioria dos casos a atualização do servidor e o final da animação vão coincidir em estado e fizemos um predição bem sucedida, fazendo com que não exista atrasos entre a ação e a renderização. Para os casos de trapaça a animação ocorrerá, mas em nada afetará o estado geral do jogo, somente afetará negativamente a experiência do usuário trapacendo.</p>
<h3 id="problemas-de-sincronização"><a class="header" href="#problemas-de-sincronização">Problemas de sincronização</a></h3>
<p>Infelizmente essa estratégia não é perfeita e problemas de sincronização ou eventos conflitantes podem acontecer. Imagine agora o cenário na qual o personagem está se movimentando e o tempo de atraso é 75 ms em vez dos 50 ms anteriores, o tempo da animação é de 30 ms e a pessoa pressiona para se movimentar para frente 2 vezes seguidas. A imagem a seguir e os passos marcados na imagem exemplificam:</p>
<p><img src="part-1/../imagens/sync_problem.jpg" alt="Diagrama com problemas de sincronização de ações" /></p>
<ol start="0">
<li>Personagem está o ponto <code>(0,0)</code> no instante 0 ms.</li>
<li>Neste mesmo instante a pessoa pressiona para se movimentar enviando uma ação para o servidor que durará 75 ms.</li>
<li>A ação do passo 1 ativou uma animação que moveu o personagem para a posição <code>(0,1)</code> 30 ms depois.</li>
<li>Na posição <code>(0,1)</code> uma nova ação de movimentação acontece, enviando esta nova ação para o servidor que durará mais 75 ms.</li>
<li>A ação do passo 3 ativou uma nova animação que moveu o personagem para a posição <code>(0,2)</code> 30 ms depois. Já se passaram 60 ms.</li>
<li>15 ms depois de terminar a ação 4, o servidor respondeu a ação 1 fazendo o personagem voltar para posição <code>(0,1)</code>. Já se passaram 75 ms.</li>
<li>30 ms depois de terminar a ação 5, o servidor respondeu a æção 3 fazendo o personagem voltar para posição <code>(0,2)</code>. Ja se passaram 105 ms.</li>
</ol>
<p>Com este detalhamento podemos ver que pelo ponto de vista da pessoa jogando, o personagem vai responder as duas primeiras ações se movimentando até a posição <code>(0,2)</code> para então voltar para posição <code>(0,1)</code> e depois ainda voltar para posição <code>(0,2)</code> gerando uma péssima experiência de jogo, forçando assim a adotarmos uma estratégia de reconciliação.</p>
<h2 id="reconciliacão-pelo-servidor"><a class="header" href="#reconciliacão-pelo-servidor">Reconciliacão pelo servidor</a></h2>
<p>A chave deste problema é entender a diferença temporal dos cliente e do servidor, já que o cliente vê o jogo em tempo real (presente) e o servidor autoritário está no passado. Assim, sempre haverá uma diferença de sequência de comandos a serem processados entre o cliente e o servidor. Felizmente isso não é muito difícil de resolver.</p>
<p>Primeiro passo é fazer com que o cliente salve suas ações em uma sequência de comandos, assim a primeira movimentação seria a ação <code>#1</code> e a segunda movimentação seria a ação <code>#2</code>. Logo, o servidor poderá respoderá responder uma ação identificando a qual comando ela pertence. A figura a seguir exemplifica o que acontece:</p>
<p><img src="part-1/../imagens/reconciliacao.jpg" alt="Diagrama de reconciliação de ações" /></p>
<ol>
<li>O evento <code>#1</code> é lancado, 30 ms depois da animação a posição <code>#1 =&gt; (0,1)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#1</code>. A sequência de comandos é <code>[#1 =&gt; (0,1)]</code>.</li>
<li>O evento <code>#2</code> é lancado, 30 ms depois da animação a posição <code>#2 =&gt; (0,2)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#2</code>.  A sequência de comandos é <code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>.</li>
<li>O evento <code>#1</code> é retornado pelo servidor com o valor <code>#1 =&gt; (0,1)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>) e o evento <code>#1 =&gt; (0,1)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#1 =&gt; (0,1)</code> da sequência de comandos.</li>
<li>O evento <code>#2</code> é retornado pelo servidor com o valor <code>#2 =&gt; (0,2)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#2 =&gt; (0,2)]</code>) e o evento <code>#2 =&gt; (0,2)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#2 =&gt; (0,2)</code> da sequência de comandos.</li>
<li>Sequência de comandos é <code>[]</code>.</li>
</ol>
<blockquote>
<p><strong>Descrição da função <code>check</code></strong></p>
<ol>
<li>Argumentos são <strong>sequência de comandos executados</strong> e <strong>evento #</strong>.</li>
<li>Verifica se o valor de <code>#n</code> na sequência de comando é igual ao que o servidor retornou. Caso não for igual retorna erro.</li>
<li>Aplica o próximo evento, <code>#n+1</code>, ao resultado do evento <code>#n</code>. Caso o resultado de <code>#n</code> mais o evento <code>#n+1</code> não corresponder ao evento salvo na sequência de comandos para <code>#n+1</code> retornar erro.
<strong>Observação</strong>: Se o evento que o servidor responder não for <code>#n</code> esperado, podemos concluir que o pacote se perdeu ou o servidor retornou um erro, assim existem duas alternativas <strong>1.</strong> descartar todos os pacotes até o evento recebido e fazer o check, ou <strong>2.</strong> aplciar todos os eventos anteriores até o evento recebido. Particularmente vejo a soluação <strong>1</strong> sendo a mais comum, pois sabemos que o estado anterior está certo.</li>
</ol>
</blockquote>
<p>Este é um exemplo bem simples de movimentação e bastante intuitivo de visualizar, mas as aplicações de predição e reconciliação podem ser feitas em praticamente qualquer área do jogo e qualquer tipo de jogo. Imagine um jogo de corrida multiplayer e você está na linha de chegada em velocidade máxima, com um carro logo atrás de você. No próximo segundo considerando as atuais circunstâncias, é óbvio que você vai ganhar, pois você está na frente do outro carro e com uma velocidade maior, mas agora imagine que alguns milésimos antes do final da corrida a outra pessoa apertou o botão de nitro e te ultrapassou. A predição diria que seu carro ganharia a corrida, mas o servidor disse que não e você ficou em segundo lugar. Isso nos leva a um ponto interessante, mesmo em ambientes determinísticos, existe a chance da predição e da reconciliação não serem iguais, Para um cenário de fim de jogo como descrito aqui é bastante trivial a resposta, ignore a predição e responda com o resultado do servidor, porém se isso acontecer frequentemente no meio do jogo a experiência de jogabilidade vai ser ruim.</p>
<p>No próximo capítulo vamos explorar como resolver este problema de predição e reconciliação através de interpolação de entidades.</p>
<h1 id="interpolação-de-entidades"><a class="header" href="#interpolação-de-entidades">Interpolação de Entidades</a></h1>
<p>Nos capítulos anteriores lidamos com o problema de uma pessoa poder trapacear e como fazer com que o jogo se mantenha conciliado com um servidor autoritário dando a sensação de que o servidor não existe, porém não expandimos este problema para quando estamos lidando com mais de uma pessoa jogando online. Neste capítulo vamos explorar técnicas que nos permitem manter a jogabilidade quando várias pessoas estão interagindo umas com as outras em um ambiente online.</p>
<h2 id="lidando-com-centenas-de-ações-simultâneas"><a class="header" href="#lidando-com-centenas-de-ações-simultâneas">Lidando com centenas de ações simultâneas</a></h2>
<p>No capítulo anterior falamos sobre o servidor processar uma sequência de comandos e retornar como eventos autoritários para o cliente. Imagine agora que este cliente está alucinadamente mandando eventos para o servidor e que ele não está sozinho, pois existem mais uma dezena de clientes mandando eventos simultaneamente para o servidor. Sendo assim, atualizar o estado do jogo para cada comando recebido de cada cliente e depois transmitir o estado do jogo de volta para cada cliente consumiria muita CPU e muita banda.</p>
<p>Tendo em vista evitar o consumo desnecessário de CPU e banda outra abordagem parece fundamental. Esta nova abordagem consiste em enfileirar os comandos que os clientes enviam, sem processar eles, e em vez de atualizar o estado do jogo imediatamente para cada comando, fazemos atualizações periódicas e de baixa frequência, por exemplo 10 vezes por segundo. Este atraso entre cada update, no caso do nosso exemplo de 100 ms, é chamado de <em>time step</em>, ou passo temporal. O <em>time step</em> é definido como uma iteração de loop de update na qual todas as informações não processdas de todos clientes são aplicadas e o novo estado é transmitido para todos os clientes. Ou seja, o estado do jogo é atualizado com uma periodicidade específica de forma independente e não é afetado pela quantidade de clientes e seus comandos.</p>
<p><strong>Obs</strong>: Muitas vezes a física do jogo é atualizada em passos de tempo menor para aumentar a previsibilidade.</p>
<h2 id="updates-de-baixa-frequência"><a class="header" href="#updates-de-baixa-frequência">Updates de baixa frequência</a></h2>
<p>Seguindo com o conceito de um update de estado a cada 100 ms um novo problema aparece, os outros clientes não tem ideia de como seus oponentes estão se atualizando, gerando eventos que parecem bastante bruscos a cada atualização. Ou seja, predição e reconciliação funcionam muito bem para o lado do cliente, mas não para o resto das pessoas jogando. A imagem a seguir detalha melhor essa situação:</p>
<p><img src="part-1/../imagens/step_time.jpg" alt="Diagrama de efeitos do step time para dois clientes" /></p>
<p>Na imagem anterior podemos ver o mesmo cenário de predição e reconciliação funcionando muito bem para o <code>Cliente 1</code>, permitindo que sua jogabilidade seja coerente com a jogabilidade de um jogo single-player, porém para o <code>Cliente 2</code> podemos ver que as transições <code>(0,0) -&gt; (0, 1)</code> e <code>(0, 1) -&gt; (0, 2)</code> do <code>Cliente 1</code> são bruscas para o <code>Cliente 2</code>, já que estas atualizações dependem exclusivamente das atualizações do servidor.</p>
<p>Agora voltando ao exemplo dos carros que mencionamos no final do capítulo anterior. Estamos em uma situação na qual temos controle do nosso carro, mas o carro da outra pessoa é determinado pelo servidor. Se este carro recebe atualizações apenas a cada 100 ms, teremos uma animação péssima de seu deslocamento, nos obrigando a encontrar outra solução para melhorar a experienência. Esta outra soluação envolve fazer a predição da posição do outro carro do lado do nosso cliente, pois sabemos sua direção, sua velocidade e temos certeza que o carro não fará um movimento radical, como girar 180 graus. Sendo assim, se o outro carro está indo reto com uma velocidade de 100 km/h, podemos prever que nos próximos 100 ms o carro estará 0,2 metros a frente de onde ele está neste exato segundo. Essa predição pode parecer maravilhosa, já que ele só se deslocou 0,2 metros em linha reta, mas infelizmente 100 ms é tempo suficiente para muitas outras coisas acontecerem como uma curva aparecer, bater em um poste, desacelerar ou até mesmo frear bruscamente. Chamamos está técnica de <strong>dead reckoning</strong>. Portanto, o <strong>dead reckoning</strong> é uma técnica de predição dos movimentos de outras pessoas em jogos na qual sua posição, velocidade e direção não são afetadas de forma instantânea, permitindo uma pequena margem para prever movimentos sem grandes danos à experiência. Caso alguma ação inesperada aconteça aceitamos que vamos conviver com uma cena estranha.</p>
<blockquote>
<p><strong>Dead reckoning</strong> é originalmente uma estratégia militar para prever a próxima localização de um navio, que se move lentamente e sem grandes oscilações de direção, para que se possa prever onde um torpedo precisa ser lançado para acertar o navio.</p>
</blockquote>
<h2 id="e-para-cenários-muito-dinâmicos"><a class="header" href="#e-para-cenários-muito-dinâmicos">E para cenários muito dinâmicos?</a></h2>
<p>Como falamos anteriormente, <em>dead reckoning</em> é bom para jogos que não são tão dinâmicos, como jogos de corrida, porém para jogos na qual as pessoas jogando se movimentam constantemente, atiram, se abaixam, pulam, giram 180 graus é impossível prever o próximo passo da pessoa apenas com dados anteriores. Se aplicássemos dead reckoning em um jogo de tiro veríamos personagens se teletransportando pequenas distâncias, múltiplas balas saindo de diferentes lugares e personagens fazendo movimentos impossíveis. Sendo assim, outra estratégia é necessária para jogos de tiro, sendo essa a <strong>interpolação de entidades</strong>.</p>
<p>No cenário descrito do parágrafo anterior, temos certeza apenas de 1 coisa, que a cada 100 ms temos uma atualização das informações do estado do jogo e dos personagens. Tendo em vista que sabemos o passado todo, o truque é mostrar para pessoa jogando o que acontece entre esses dados que já sabemos. Ou seja, a solução é mostrar para a pessoa que está jogando o passado relativo dos outros personagens. Isso que chamamos de <strong>interpolação de entidades</strong>.</p>
<p>Explicando melhor, podemos dizer que no momento <code>t = n + 1</code>, que você acabou de receber, a posição do momento <code>t = n</code> é conhecida. Sendo assim, neste momento <code>t = n + 1</code> conhecemos as posições referentes a <code>t = n</code> e <code>t = n + 1</code>. Portanto, para o momento <code>t = n + 2</code> mostramos o passado, ou seja, o que ocorreu no momento <code>t = n = 1</code> e para o momento <code>t = n + 1</code> mostramos o que ocorreu no momento <code>t = n</code> do outro personagem. Deste modo o servidor está sempre mostrando as informações reais de movimentação dos outros personagens, porém com um &quot;pequeno atraso&quot; de 100 ms. A imagem a seguir exemplifica:</p>
<p><img src="part-1/../imagens/interpolation.jpg" alt="Diagrama de interpolação" /></p>
<p>O diagrama de interpolação nos mostra bem como estamos prevendo os passos intermediários. Para um momento inicial estamos com a posição <code>P(0,1)</code>, depois o servidor nos atualiza com a posição <code>P(0,1)</code> novamente, neste momento exibimos a posição que conheciamos antes do <em>step time</em>, a <code>V(0,1)</code>. Quando recebemos a posição <code>P(0,2)</code>, mantemos a posição <code>V(0,1)</code>, que havia sido entregue anteriormente pelo servidor. Agora sabemos o vetor de posições <code>[P(0, 1), #1 P(0, 1), #2 P(0, 2)]</code>, e podemos interpolar que no próximo <em>step time</em> nosso personagem inimigo vai para a posição <code>V(0,2)</code> passando pela posição <code>V(0,1.75)</code>, melhorando a experiência da pessoa jogadora.</p>
<p>Na maior parte dos casos interpolação funciona muito bem, porém existem alguns casos que pode ser importante enviar mais informações de posições intermediárias entre <code>#1</code> e <code>#2</code>. Ou seja, se atualizações de estado a cada 100 ms não são suficientes, podemos enviar as últimas 10 atualizações que ocorreram com intervalos de 10 ms, que certamente vai fazer com que seu jogo pareça mais realista. Note que está técnica faz com que cada jogadora perceba pequenas variações do ambiente do jogo em relação às outras pessoas, que geralmente não é algo perceptível. Infelizmente, nada é perfeito e existem exceções como no caso de quando damos um tiro, pois estamos atirando na personagem da outra pessoa de 100 ms atrás. É nesse caso que precisamos explorar o último tópico desta parte, compensação de lag.</p>
<h1 id="compensacão-de-lag"><a class="header" href="#compensacão-de-lag">Compensacão de Lag</a></h1>
<p>O cenário que temos até agora parece funcionar muito bem para percebermos movimentações, pois temos:</p>
<ul>
<li>Dado um tempo n, nosso servidor recebe informações de todos os clientes.</li>
<li>Servidor processa todas as informações e transmite as atualizações.</li>
<li>Estas atualizações são periódicas e de baixa frequência.</li>
<li>Clientes enviam informações e verificam seus efeitos localmente.</li>
<li>Clientes recebem as atualizações de estado do jogo:
<ol>
<li>Reconciliam com os efeitos que previram.</li>
<li>Interpolam os efeitos dos outros personagens.</li>
</ol>
</li>
<li>Cliente se vê no presente, mas vê os outros cliente no passado.</li>
</ul>
<p>Esta situação é geralmente ótima, a menos quando precisamos garantir situações como um tiro na cabeça, que qualquer pequena variação pode causar um erro, pois as informações de tempo e espaço são muito sensíveis. É ai que entra a compensação de lag.</p>
<p>Imagine o cenário na qual você é uma sniper mirando perfeitamente na cabeça de um personagem &quot;imóvel&quot;, um tiro dificil de errar. Você atira e, magicamente, nada acontece. Você se irrita, sai da partida e desliga o jogo pensando como pode ter errado aquele tiro perfeito e, pior, a pessoa que você devia ter matado te matou. Este é o efeito de lag temporal, pois seu tiro ocorreu em um personagem que estava 100 ms no passado, para quem gosta de física, é como se a velocidade da luz fosse muito muito muito inferior a que realmente é. Felizmente, existem algumas estratégias para resolver este efeito. Vamos detalhar como isso pode ser reolvido:</p>
<ol>
<li>Você deu um tiro, seu cliente enviou as informações para o servidor, mas desta vez enviou mais informações além do botão que você clicou, pois enviou o botão que você apertou, o exato momento temporal que você apertou o botão (e se o botão de mira estava sendo apertado) e o que estava exatamente em sua mira neste instante.</li>
<li>Como o servidor está recebendo todos momentos temporais, ele pode reconstruir os eventos temporalmente ordenados, ou seja, o servidor pode reconstruir o mundo no exato momento de seu tiro, assim como para todos outros clientes.</li>
<li>Sabendo o que sua arma estava mirando no momento de seu tiro, a cabeça de seu inimigo, seu presente passa a ser considerado como válido no servidor, já que ele compensa esta diferenca.</li>
<li>O servidor processa o tiro e transmite para todos os clientes, deixando seu oponente furioso por ter levado um headshot.</li>
</ol>
<p>E é no passo dois que a compensacão de lag ocorre.</p>
<h2 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h2>
<p>Primeira coisa que fizemos foi entender qual o grande problema do desenvolvimento de servidores para jogos, pessoas querendo trapacear, e a partir disso entendemos qual a solução básica, um cliente que só envia comandos pro servidor e um servidor autoritário. Vimos que com um servidor autoritário alguns problemas de defasamento temporal pode ocorrer entre a informação que temos e a informação que o servidor nos obriga a ter. Para reduzir estes problemas aprendemos as técncias de predição e de reconciliação, mas descobrimos problemas de sincronização com outros clientes. Para resolver os problemas de sincronização aprendemos as técncias de dead reckoning e interpolação de entidades, que são ótimas técnicas, mas ainda podem falhar na hora que ações muito sensíveis espacialmente são executadas. Para resolver este problema de ações sensíveis, aprendemos compensação de lag, mas ainda nos falta por a mão na massa. Nos próximos capítulos vamos explorar um jogo simples de tiro e um exemplo de servidor para ele.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
